<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warp Shot</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
        }
        #player-stats, #enemy-stats {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        #game-over-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        #restart-button {
            padding: 12px 25px;
            font-size: 20px;
            cursor: pointer;
            background-color: #333;
            color: white;
            border: 2px solid #555;
            border-radius: 5px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        #restart-button:hover {
            background-color: #555;
            border-color: #777;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="player-stats">
            <span>PLAYER HP: </span><span id="player-hp"></span><br>
            <span>AMMO: </span><span id="player-ammo"></span>
        </div>
        <div id="enemy-stats">
            <span>ENEMY HP: </span><span id="enemy-hp"></span>
        </div>
    </div>

    <div id="game-over-screen">
        <h1 id="game-over-text"></h1>
        <button id="restart-button">RESTART</button>
    </div>

    <!-- Three.jsの読み込み -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js"
        }
    }
    </script>

    <!-- ゲームスクリプト (全クラスをここに集約) -->
    <script type="module">
        import * as THREE from 'three';

        // ==================================================================
        // ===== Audio Utility (Web Audio API for Sound Effects) ==========
        // ==================================================================

        let audioCtx;
        let bgmOscillator;
        let bgmGain;
        const bgmNotes = [220.00, 220.00, 246.94, 220.00, 220.00, 261.63, 246.94, 220.00]; // Simple note sequence
        let bgmNoteIndex = 0;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;
            const gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);

            switch (type) {
                case 'shoot':
                    const oscShoot = audioCtx.createOscillator();
                    oscShoot.type = 'triangle';
                    oscShoot.frequency.setValueAtTime(880, now);
                    oscShoot.frequency.exponentialRampToValueAtTime(220, now + 0.1);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscShoot.connect(gainNode);
                    oscShoot.start(now);
                    oscShoot.stop(now + 0.1);
                    break;
                case 'hit':
                    const oscHit = audioCtx.createOscillator();
                    oscHit.type = 'square';
                    oscHit.frequency.setValueAtTime(440, now);
                    gainNode.gain.setValueAtTime(0.4, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    oscHit.connect(gainNode);
                    oscHit.start(now);
                    oscHit.stop(now + 0.2);
                    break;
                case 'warp':
                    const oscWarp = audioCtx.createOscillator();
                    oscWarp.type = 'sawtooth';
                    oscWarp.frequency.setValueAtTime(100, now);
                    oscWarp.frequency.exponentialRampToValueAtTime(1000, now + 0.15);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.15);
                    oscWarp.connect(gainNode);
                    oscWarp.start(now);
                    oscWarp.stop(now + 0.15);
                    break;
                case 'destroy':
                    const oscDestroy = audioCtx.createOscillator();
                    oscDestroy.type = 'noise';
                    gainNode.gain.setValueAtTime(0.5, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
                    oscDestroy.connect(gainNode);
                    oscDestroy.start(now);
                    oscDestroy.stop(now + 1.0);
                    break;
                case 'bgm':
                    if (bgmOscillator) bgmOscillator.stop();
                    initAudio();
                    bgmOscillator = audioCtx.createOscillator();
                    bgmGain = audioCtx.createGain();
                    bgmOscillator.type = 'sine';
                    bgmGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    bgmOscillator.connect(bgmGain).connect(audioCtx.destination);
                    bgmOscillator.start();
                    
                    const playNextNote = () => {
                        if(!bgmOscillator) return;
                        const note = bgmNotes[bgmNoteIndex % bgmNotes.length];
                        bgmOscillator.frequency.setValueAtTime(note, audioCtx.currentTime);
                        bgmNoteIndex++;
                        setTimeout(playNextNote, 500);
                    };
                    playNextNote();
                    break;
            }
        }
        
        function stopBGM() {
            if(bgmOscillator) {
                bgmGain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
                bgmOscillator.stop(audioCtx.currentTime + 0.5);
                bgmOscillator = null;
            }
        }

        // ==================================================================
        // ===== Bullet Class =============================================
        // ==================================================================
        const BULLET_SPEED = 0.8; // ★修正: 弾速を遅くした

        class Bullet {
            constructor(scene, owner, game) {
                this.scene = scene;
                this.owner = owner;
                this.game = game;

                this.speed = BULLET_SPEED;
                this.size = 0.8;
                
                const geometry = new THREE.SphereGeometry(this.size, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: this.owner.mesh.material.color });
                this.mesh = new THREE.Mesh(geometry, material);

                this.mesh.position.copy(this.owner.mesh.position);
                const direction = new THREE.Vector3(0, 1, 0);
                direction.applyQuaternion(this.owner.mesh.quaternion);
                this.velocity = direction.multiplyScalar(this.speed);
                
                this.scene.add(this.mesh);
            }

            update() {
                this.mesh.position.add(this.velocity);
                this.checkWarp();
            }

            checkWarp() {
                const worldWidth = this.game.frustumSize * this.game.aspect / 2;
                const worldHeight = this.game.frustumSize / 2;

                let warped = false;
                if (this.mesh.position.x > worldWidth) {
                    this.mesh.position.x = -worldWidth;
                    warped = true;
                } else if (this.mesh.position.x < -worldWidth) {
                    this.mesh.position.x = worldWidth;
                    warped = true;
                }

                if (this.mesh.position.y > worldHeight) {
                    this.mesh.position.y = -worldHeight;
                    warped = true;
                } else if (this.mesh.position.y < -worldHeight) {
                    this.mesh.position.y = worldHeight;
                    warped = true;
                }
                if (warped) {
                    playSound('warp');
                }
            }

            removeFromScene() {
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // ==================================================================
        // ===== Character Class (Base) ===================================
        // ==================================================================
        class Character {
            constructor(scene, game, position, color) {
                this.scene = scene;
                this.game = game;
                
                this.size = 2.5;
                this.sizeSq = this.size * this.size;
                const geometry = new THREE.ConeGeometry(this.size, this.size * 2, 4);
                const material = new THREE.MeshBasicMaterial({ color });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.mesh.rotation.x = Math.PI / 2;
                this.scene.add(this.mesh);

                this.hp = 10;
                this.maxAmmo = 5;
                this.ammo = this.maxAmmo;
                this.baseSpeed = 0.5;
                this.speed = this.baseSpeed;
                
                this.distanceForAmmo = 0;
                this.distanceToGetAmmo = 60; // ★修正: 弾補充の必要距離を増加

                this.fireCooldown = 300; // ms
                this.lastFireTime = 0;
            }

            shoot() {
                const now = Date.now();
                if (this.ammo > 0 && now - this.lastFireTime > this.fireCooldown) {
                    this.ammo--;
                    this.lastFireTime = now;
                    
                    const bullet = new Bullet(this.scene, this, this.game);
                    this.game.bullets.push(bullet);
                    playSound('shoot');
                    return true;
                }
                return false;
            }
            
            updateSpeed() {
                const speedModifier = 1.0 - (this.ammo / this.maxAmmo) * 0.7; 
                this.speed = this.baseSpeed * speedModifier;
            }

            addAmmoOnMove(distance) {
                this.distanceForAmmo += distance;
                if (this.distanceForAmmo >= this.distanceToGetAmmo) {
                    if (this.ammo < this.maxAmmo) {
                        this.ammo++;
                    }
                    this.distanceForAmmo = 0;
                }
            }

            takeDamage(amount) {
                this.hp = Math.max(0, this.hp - amount);
            }

            isDead() {
                return this.hp <= 0;
            }
            
            destroy() {
                this.mesh.scale.set(1.5, 1.5, 1.5);
                let scale = 1.5;
                const shrink = () => {
                    scale -= 0.05;
                    if(scale > 0){
                       this.mesh.scale.set(scale, scale, scale);
                       this.mesh.rotation.z += 0.5;
                       requestAnimationFrame(shrink);
                    } else {
                       this.scene.remove(this.mesh);
                    }
                };
                shrink();
            }
        }

        // ==================================================================
        // ===== Player Class ===============================================
        // ==================================================================
        class Player extends Character {
            constructor(scene, game, position, color) {
                super(scene, game, position, color);
                this.keys = {};
                document.addEventListener('keydown', (e) => this.keys[e.code] = true);
                document.addEventListener('keyup', (e) => this.keys[e.code] = false);

                this._moveVector = new THREE.Vector3();
                this.mesh.rotation.z = -Math.PI / 2;
            }

            update() {
                this._moveVector.set(0, 0, 0);
                if (this.keys['KeyW']) this._moveVector.y += 1;
                if (this.keys['KeyS']) this._moveVector.y -= 1;
                if (this.keys['KeyA']) this._moveVector.x -= 1;
                if (this.keys['KeyD']) this._moveVector.x += 1;

                this.updateSpeed();
                
                if (this._moveVector.lengthSq() > 0) {
                    this._moveVector.normalize().multiplyScalar(this.speed);
                    this.mesh.position.add(this._moveVector);
                    this.addAmmoOnMove(this._moveVector.length());
                }

                if (this.keys['Space']) {
                    this.shoot();
                }

                this.keepInBounds();
            }

            keepInBounds() {
                const worldWidth = this.game.frustumSize * this.game.aspect / 2 - this.size;
                const worldHeight = this.game.frustumSize / 2 - this.size;
                this.mesh.position.x = Math.max(-worldWidth, Math.min(0 - this.size, this.mesh.position.x));
                this.mesh.position.y = Math.max(-worldHeight, Math.min(worldHeight, this.mesh.position.y));
            }
        }

        // ==================================================================
        // ===== Enemy Class (AI) =========================================
        // ==================================================================
        class Enemy extends Character {
            constructor(scene, game, position, color) {
                super(scene, game, position, color);
                // ★AIの思考パターンを追加
                this.aiState = 'STANDARD_ATTACK'; // 'AVOIDING', 'RETREATING', 'FARMING_AMMO', 'AGGRESSIVE_ATTACK', 'STANDARD_ATTACK'
                
                this.thinkInterval = 30; // 30フレーム(約0.5秒)ごとに思考する
                this.thinkCooldown = this.thinkInterval;

                // ベクトルを再利用してパフォーマンス改善
                this._moveDirection = new THREE.Vector3();
                this._targetPosition = new THREE.Vector3(this.mesh.position.x, 0, 0); // 初期目標
                this._toMeVector = new THREE.Vector3();
                this._evasionDir = new THREE.Vector3();
                this._pos1 = new THREE.Vector3();
                this._pos2 = new THREE.Vector3();

                // 向きを常に左（プレイヤー側）に固定
                this.mesh.rotation.z = Math.PI / 2;
            }
            
            // ★AIの思考ルーチン
            think(player) {
                const myPos = this.mesh.position;
                const playerPos = player.mesh.position;

                // 状況評価
                const isMyHpLow = this.hp <= 3;
                const isMyAmmoLow = this.ammo <= 1;
                const isPlayerHpLow = player.hp <= 4;
                const hasEnoughAmmo = this.ammo >= 3;

                // 戦略決定
                let newState = 'STANDARD_ATTACK';
                if (isMyHpLow) {
                    newState = 'RETREATING';
                } else if (isMyAmmoLow) {
                    newState = 'FARMING_AMMO';
                } else if (isPlayerHpLow && hasEnoughAmmo) {
                    newState = 'AGGRESSIVE_ATTACK';
                }
                
                // 状態が切り替わったか、目標に到達したら新しい目標を設定
                if (this.aiState !== newState || myPos.distanceTo(this._targetPosition) < this.size) {
                    this.aiState = newState;
                    
                    const worldHeight = this.game.frustumSize / 2 - this.size;
                    const worldWidthHalf = (this.game.frustumSize * this.game.aspect / 2 - this.size) / 2;
                    
                    switch(this.aiState) {
                        case 'RETREATING':
                            // プレイヤーから最も遠いコートの隅を目指す
                            this._targetPosition.x = this.size;
                            this._targetPosition.y = (playerPos.y > 0 ? -1 : 1) * worldHeight;
                            break;
                            
                        case 'FARMING_AMMO':
                            // コート内をランダムに大きく動き回り、弾を補充
                            this._targetPosition.x = this.size + Math.random() * worldWidthHalf;
                            this._targetPosition.y = (Math.random() * 2 - 1) * worldHeight;
                            break;

                        case 'AGGRESSIVE_ATTACK':
                            // プレイヤーのY座標に直接合わせにいく
                            this._targetPosition.x = myPos.x;
                            this._targetPosition.y = playerPos.y;
                            break;

                        case 'STANDARD_ATTACK':
                            // プレイヤーのY座標を基準に、上下に揺さぶりをかける
                            this._targetPosition.x = myPos.x;
                            const randomOffsetY = (Math.random() * 60 - 30); // -30～+30のオフセット
                            this._targetPosition.y = THREE.MathUtils.clamp(playerPos.y + randomOffsetY, -worldHeight, worldHeight);
                            break;
                    }
                }
            }

            update(player, bullets) {
                this.updateSpeed();

                // --- 思考 ---
                this.thinkCooldown--;
                if (this.thinkCooldown <= 0) {
                    this.think(player);
                    this.thinkCooldown = this.thinkInterval + Math.floor(Math.random() * 15); // 少し間隔をランダムに
                }

                // --- 行動決定 ---
                this._moveDirection.set(0, 0, 0);
                
                // 1. 緊急回避 (最優先)
                const threateningBullet = this.findThreateningBullet(bullets);
                if (threateningBullet) {
                    this.getEvasionVector(threateningBullet, this._moveDirection);
                } else {
                // 2. 戦略に基づく行動
                    this._moveDirection.subVectors(this._targetPosition, this.mesh.position);
                    
                    // 攻撃判定
                    const isAttacking = this.aiState === 'AGGRESSIVE_ATTACK' || this.aiState === 'STANDARD_ATTACK';
                    if (isAttacking) {
                        // プレイヤーが射線上にいるか（Y座標がある程度近いか）
                        const yDiff = Math.abs(this.mesh.position.y - player.mesh.position.y);
                        if (yDiff < 15) { // 射線が合っていると判断する許容範囲
                             this.shoot();
                        }
                    }
                }
                
                // --- 実行 ---
                if (this._moveDirection.lengthSq() > 0) {
                    this._moveDirection.normalize().multiplyScalar(this.speed * 0.8);
                    this.mesh.position.add(this._moveDirection);
                    this.addAmmoOnMove(this._moveDirection.length());
                }

                this.keepInBounds();
            }
            
            findThreateningBullet(bullets) {
                let closestThreat = null;
                let minDistanceSq = 30 * 30; // 脅威とみなす範囲を少し広げる

                for (const bullet of bullets) {
                    if (bullet.owner === this) continue;

                    const distSq = bullet.mesh.position.distanceToSquared(this.mesh.position);
                    if (distSq < minDistanceSq) {
                        this._toMeVector.subVectors(this.mesh.position, bullet.mesh.position);
                        if (bullet.velocity.dot(this._toMeVector) > 0) { // 自分に向かっているか
                            minDistanceSq = distSq;
                            closestThreat = bullet;
                        }
                    }
                }
                return closestThreat;
            }
            
            getEvasionVector(bullet, outVector) {
                outVector.set(-bullet.velocity.y, bullet.velocity.x, 0); // 弾の進行方向と垂直
                this._pos1.copy(this.mesh.position).add(outVector);
                this._pos2.copy(this.mesh.position).sub(outVector);

                if (this._pos1.distanceToSquared(this.game.player.mesh.position) < this._pos2.distanceToSquared(this.game.player.mesh.position)) {
                    outVector.negate();
                }
                return outVector;
            }

            keepInBounds() {
                const worldWidth = this.game.frustumSize * this.game.aspect / 2 - this.size;
                const worldHeight = this.game.frustumSize / 2 - this.size;
                this.mesh.position.x = Math.max(0 + this.size, Math.min(worldWidth, this.mesh.position.x));
                this.mesh.position.y = Math.max(-worldHeight, Math.min(worldHeight, this.mesh.position.y));
            }
        }


        // ==================================================================
        // ===== Game Class (Main Controller) =============================
        // ==================================================================
        class Game {
            constructor() {
                this.scene = new THREE.Scene();
                this.aspect = window.innerWidth / window.innerHeight;
                this.frustumSize = 100;
                this.camera = new THREE.OrthographicCamera(
                    this.frustumSize * this.aspect / -2,
                    this.frustumSize * this.aspect / 2,
                    this.frustumSize / 2,
                    this.frustumSize / -2,
                    1,
                    1000
                );
                this.camera.position.z = 10;

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x1a1a1a);
                document.body.appendChild(this.renderer.domElement);
                
                this.player = null;
                this.enemy = null;
                this.bullets = [];

                this.playerHpUI = document.getElementById('player-hp');
                this.playerAmmoUI = document.getElementById('player-ammo');
                this.enemyHpUI = document.getElementById('enemy-hp');
                this.gameOverScreen = document.getElementById('game-over-screen');
                this.gameOverText = document.getElementById('game-over-text');
                this.restartButton = document.getElementById('restart-button');
                
                this.isGameOver = false;

                window.addEventListener('resize', this.onWindowResize.bind(this), false);
                this.restartButton.addEventListener('click', () => location.reload());
                document.body.addEventListener('keydown', this.firstInteraction.bind(this), { once: true });
            }

            firstInteraction() {
                initAudio();
                playSound('bgm');
            }

            start() {
                this.isGameOver = false;
                this.gameOverScreen.style.display = 'none';

                this.player = new Player(this.scene, this, new THREE.Vector3(-30, 0, 0), 0x00aaff);
                this.enemy = new Enemy(this.scene, this, new THREE.Vector3(30, 0, 0), 0xff4444);
                
                const grid = new THREE.GridHelper(this.frustumSize * 2, 20, 0x333333, 0x222222);
                grid.rotation.x = Math.PI / 2;
                this.scene.add(grid);

                const courtLineMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, linewidth: 2 });
                const points = [];
                const worldHeight = this.frustumSize / 2;
                points.push(new THREE.Vector3(0, -worldHeight, 0));
                points.push(new THREE.Vector3(0, worldHeight, 0));
                const courtLineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const courtLine = new THREE.Line(courtLineGeometry, courtLineMaterial);
                this.scene.add(courtLine);

                this.animate();
            }

            animate() {
                if (this.isGameOver) return;
                requestAnimationFrame(this.animate.bind(this));

                this.player.update();
                this.enemy.update(this.player, this.bullets);

                this.bullets.forEach(bullet => bullet.update());

                this.checkCollisions();
                this.updateUI();

                this.renderer.render(this.scene, this.camera);
            }
            
            checkCollisions() {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    if (bullet.owner !== this.player && bullet.mesh.position.distanceToSquared(this.player.mesh.position) < this.player.sizeSq) {
                        this.player.takeDamage(1);
                        playSound('hit');
                        bullet.removeFromScene();
                        this.bullets.splice(i, 1);
                        if (this.player.isDead()) this.endGame('YOU LOSE...');
                        continue;
                    }

                    if (bullet.owner !== this.enemy && bullet.mesh.position.distanceToSquared(this.enemy.mesh.position) < this.enemy.sizeSq) {
                        this.enemy.takeDamage(1);
                        playSound('hit');
                        bullet.removeFromScene();
                        this.bullets.splice(i, 1);
                        if (this.enemy.isDead()) this.endGame('YOU WIN!');
                    }
                }
            }

            endGame(message) {
                if (this.isGameOver) return;
                this.isGameOver = true;
                
                playSound('destroy');
                stopBGM();
                
                this.gameOverText.textContent = message;
                this.gameOverScreen.style.display = 'flex';

                if (message.includes('WIN')) {
                    this.enemy.destroy();
                } else {
                    this.player.destroy();
                }
            }

            updateUI() {
                this.playerHpUI.textContent = this.player.hp;
                this.playerAmmoUI.textContent = `${this.player.ammo} / ${this.player.maxAmmo}`;
                this.enemyHpUI.textContent = this.enemy.hp;
            }

            onWindowResize() {
                this.aspect = window.innerWidth / window.innerHeight;
                this.camera.left = this.frustumSize * this.aspect / -2;
                this.camera.right = this.frustumSize * this.aspect / 2;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // ==================================================================
        // ===== Main Execution ===========================================
        // ==================================================================
        window.addEventListener('DOMContentLoaded', () => {
            const game = new Game();
            game.start();
        });

    </script>
</body>
</html>