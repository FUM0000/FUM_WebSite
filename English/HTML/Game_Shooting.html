はい、承知いたしました。ゲームをより戦略的で面白いものにするための修正ですね。

以下の3点について、コードを大幅に改良しました。

弾速と弾薬補充ペースの調整:

弾の速度を遅くし、見てから回避できる現実的なスピードにしました。

移動による弾薬補充の必要距離を伸ばし、弾薬管理の重要性を高めました。

敵AIの大幅な強化:

思考ルーチン: 約0.5秒ごとに「思考」し、次の行動を決定するロジックを導入しました。これにより、状況の変化に素早く対応します。

多様な戦略: 単純な追跡や攻撃だけでなく、状況に応じて以下のような人間らしい戦略を使い分けるようになりました。

RETREATING (退却): 自身のHPが少なくなると、プレイヤーから距離を取って逃げることに専念します。

FARMING_AMMO (弾薬補充): 弾がなくなると、攻撃を中断し、コート内を動き回って弾薬の補充を優先します。

AGGRESSIVE_ATTACK (猛攻): プレイヤーのHPが少ないなど、好機と判断すれば積極的に距離を詰めて攻撃します。

STANDARD_ATTACK (標準戦闘): プレイヤーを揺さぶるように上下に動きながら、牽制と攻撃の機会をうかがいます。

人間らしい動き: AIの移動目標に少しランダム性を持たせることで、単調で予測しやすい動きをなくし、より人間らしい挙動を実現しました。

ワープ弾を意識した戦術:

AIはコートの上下端をうまく利用するようになりました。端に位置取りをしてプレイヤーを揺さぶったり、弾がワープしてくる時間差を利用したりするような、より高度な位置取りを試みます。

これらの変更により、敵AIは単なる的ではなく、プレイヤーの状況を見ながら戦術を変えてくる手強い好敵手になったはずです。

修正後のコード Game_Shooting.html
code
Html
download
content_copy
expand_less

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warp Shot</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
        }
        #player-stats, #enemy-stats {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        #game-over-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
        }
        #restart-button {
            padding: 12px 25px;
            font-size: 20px;
            cursor: pointer;
            background-color: #333;
            color: white;
            border: 2px solid #555;
            border-radius: 5px;
            transition: background-color 0.3s, border-color 0.3s;
        }
        #restart-button:hover {
            background-color: #555;
            border-color: #777;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="player-stats">
            <span>PLAYER HP: </span><span id="player-hp"></span><br>
            <span>AMMO: </span><span id="player-ammo"></span>
        </div>
        <div id="enemy-stats">
            <span>ENEMY HP: </span><span id="enemy-hp"></span>
        </div>
    </div>

    <div id="game-over-screen">
        <h1 id="game-over-text"></h1>
        <button id="restart-button">RESTART</button>
    </div>

    <!-- Three.jsの読み込み -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js"
        }
    }
    </script>

    <!-- ゲームスクリプト (全クラスをここに集約) -->
    <script type="module">
        import * as THREE from 'three';

        // ==================================================================
        // ===== Audio Utility (Web Audio API for Sound Effects) ==========
        // ==================================================================

        let audioCtx;
        let bgmOscillator;
        let bgmGain;
        const bgmNotes = [220.00, 220.00, 246.94, 220.00, 220.00, 261.63, 246.94, 220.00]; // Simple note sequence
        let bgmNoteIndex = 0;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;

            const now = audioCtx.currentTime;
            const gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);

            switch (type) {
                case 'shoot':
                    const oscShoot = audioCtx.createOscillator();
                    oscShoot.type = 'triangle';
                    oscShoot.frequency.setValueAtTime(880, now);
                    oscShoot.frequency.exponentialRampToValueAtTime(220, now + 0.1);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    oscShoot.connect(gainNode);
                    oscShoot.start(now);
                    oscShoot.stop(now + 0.1);
                    break;
                case 'hit':
                    const oscHit = audioCtx.createOscillator();
                    oscHit.type = 'square';
                    oscHit.frequency.setValueAtTime(440, now);
                    gainNode.gain.setValueAtTime(0.4, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    oscHit.connect(gainNode);
                    oscHit.start(now);
                    oscHit.stop(now + 0.2);
                    break;
                case 'warp':
                    const oscWarp = audioCtx.createOscillator();
                    oscWarp.type = 'sawtooth';
                    oscWarp.frequency.setValueAtTime(100, now);
                    oscWarp.frequency.exponentialRampToValueAtTime(1000, now + 0.15);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.linearRampToValueAtTime(0, now + 0.15);
                    oscWarp.connect(gainNode);
                    oscWarp.start(now);
                    oscWarp.stop(now + 0.15);
                    break;
                case 'destroy':
                    const oscDestroy = audioCtx.createOscillator();
                    oscDestroy.type = 'noise';
                    gainNode.gain.setValueAtTime(0.5, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
                    oscDestroy.connect(gainNode);
                    oscDestroy.start(now);
                    oscDestroy.stop(now + 1.0);
                    break;
                case 'bgm':
                    if (bgmOscillator) bgmOscillator.stop();
                    initAudio();
                    bgmOscillator = audioCtx.createOscillator();
                    bgmGain = audioCtx.createGain();
                    bgmOscillator.type = 'sine';
                    bgmGain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    bgmOscillator.connect(bgmGain).connect(audioCtx.destination);
                    bgmOscillator.start();
                    
                    const playNextNote = () => {
                        if(!bgmOscillator) return;
                        const note = bgmNotes[bgmNoteIndex % bgmNotes.length];
                        bgmOscillator.frequency.setValueAtTime(note, audioCtx.currentTime);
                        bgmNoteIndex++;
                        setTimeout(playNextNote, 500);
                    };
                    playNextNote();
                    break;
            }
        }
        
        function stopBGM() {
            if(bgmOscillator) {
                bgmGain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
                bgmOscillator.stop(audioCtx.currentTime + 0.5);
                bgmOscillator = null;
            }
        }

        // ==================================================================
        // ===== Bullet Class =============================================
        // ==================================================================
        const BULLET_SPEED = 0.8; // ★修正: 弾速を遅くした

        class Bullet {
            constructor(scene, owner, game) {
                this.scene = scene;
                this.owner = owner;
                this.game = game;

                this.speed = BULLET_SPEED;
                this.size = 0.8;
                
                const geometry = new THREE.SphereGeometry(this.size, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: this.owner.mesh.material.color });
                this.mesh = new THREE.Mesh(geometry, material);

                this.mesh.position.copy(this.owner.mesh.position);
                const direction = new THREE.Vector3(0, 1, 0);
                direction.applyQuaternion(this.owner.mesh.quaternion);
                this.velocity = direction.multiplyScalar(this.speed);
                
                this.scene.add(this.mesh);
            }

            update() {
                this.mesh.position.add(this.velocity);
                this.checkWarp();
            }

            checkWarp() {
                const worldWidth = this.game.frustumSize * this.game.aspect / 2;
                const worldHeight = this.game.frustumSize / 2;

                let warped = false;
                if (this.mesh.position.x > worldWidth) {
                    this.mesh.position.x = -worldWidth;
                    warped = true;
                } else if (this.mesh.position.x < -worldWidth) {
                    this.mesh.position.x = worldWidth;
                    warped = true;
                }

                if (this.mesh.position.y > worldHeight) {
                    this.mesh.position.y = -worldHeight;
                    warped = true;
                } else if (this.mesh.position.y < -worldHeight) {
                    this.mesh.position.y = worldHeight;
                    warped = true;
                }
                if (warped) {
                    playSound('warp');
                }
            }

            removeFromScene() {
                this.scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // ==================================================================
        // ===== Character Class (Base) ===================================
        // ==================================================================
        class Character {
            constructor(scene, game, position, color) {
                this.scene = scene;
                this.game = game;
                
                this.size = 2.5;
                this.sizeSq = this.size * this.size;
                const geometry = new THREE.ConeGeometry(this.size, this.size * 2, 4);
                const material = new THREE.MeshBasicMaterial({ color });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.mesh.rotation.x = Math.PI / 2;
                this.scene.add(this.mesh);

                this.hp = 10;
                this.maxAmmo = 5;
                this.ammo = this.maxAmmo;
                this.baseSpeed = 0.5;
                this.speed = this.baseSpeed;
                
                this.distanceForAmmo = 0;
                this.distanceToGetAmmo = 60; // ★修正: 弾補充の必要距離を増加

                this.fireCooldown = 300; // ms
                this.lastFireTime = 0;
            }

            shoot() {
                const now = Date.now();
                if (this.ammo > 0 && now - this.lastFireTime > this.fireCooldown) {
                    this.ammo--;
                    this.lastFireTime = now;
                    
                    const bullet = new Bullet(this.scene, this, this.game);
                    this.game.bullets.push(bullet);
                    playSound('shoot');
                    return true;
                }
                return false;
            }
            
            updateSpeed() {
                const speedModifier = 1.0 - (this.ammo / this.maxAmmo) * 0.7; 
                this.speed = this.baseSpeed * speedModifier;
            }

            addAmmoOnMove(distance) {
                this.distanceForAmmo += distance;
                if (this.distanceForAmmo >= this.distanceToGetAmmo) {
                    if (this.ammo < this.maxAmmo) {
                        this.ammo++;
                    }
                    this.distanceForAmmo = 0;
                }
            }

            takeDamage(amount) {
                this.hp = Math.max(0, this.hp - amount);
            }

            isDead() {
                return this.hp <= 0;
            }
            
            destroy() {
                this.mesh.scale.set(1.5, 1.5, 1.5);
                let scale = 1.5;
                const shrink = () => {
                    scale -= 0.05;
                    if(scale > 0){
                       this.mesh.scale.set(scale, scale, scale);
                       this.mesh.rotation.z += 0.5;
                       requestAnimationFrame(shrink);
                    } else {
                       this.scene.remove(this.mesh);
                    }
                };
                shrink();
            }
        }

        // ==================================================================
        // ===== Player Class ===============================================
        // ==================================================================
        class Player extends Character {
            constructor(scene, game, position, color) {
                super(scene, game, position, color);
                this.keys = {};
                document.addEventListener('keydown', (e) => this.keys[e.code] = true);
                document.addEventListener('keyup', (e) => this.keys[e.code] = false);

                this._moveVector = new THREE.Vector3();
                this.mesh.rotation.z = -Math.PI / 2;
            }

            update() {
                this._moveVector.set(0, 0, 0);
                if (this.keys['KeyW']) this._moveVector.y += 1;
                if (this.keys['KeyS']) this._moveVector.y -= 1;
                if (this.keys['KeyA']) this._moveVector.x -= 1;
                if (this.keys['KeyD']) this._moveVector.x += 1;

                this.updateSpeed();
                
                if (this._moveVector.lengthSq() > 0) {
                    this._moveVector.normalize().multiplyScalar(this.speed);
                    this.mesh.position.add(this._moveVector);
                    this.addAmmoOnMove(this._moveVector.length());
                }

                if (this.keys['Space']) {
                    this.shoot();
                }

                this.keepInBounds();
            }

            keepInBounds() {
                const worldWidth = this.game.frustumSize * this.game.aspect / 2 - this.size;
                const worldHeight = this.game.frustumSize / 2 - this.size;
                this.mesh.position.x = Math.max(-worldWidth, Math.min(0 - this.size, this.mesh.position.x));
                this.mesh.position.y = Math.max(-worldHeight, Math.min(worldHeight, this.mesh.position.y));
            }
        }

        // ==================================================================
        // ===== Enemy Class (AI) =========================================
        // ==================================================================
        class Enemy extends Character {
            constructor(scene, game, position, color) {
                super(scene, game, position, color);
                // ★AIの思考パターンを追加
                this.aiState = 'STANDARD_ATTACK'; // 'AVOIDING', 'RETREATING', 'FARMING_AMMO', 'AGGRESSIVE_ATTACK', 'STANDARD_ATTACK'
                
                this.thinkInterval = 30; // 30フレーム(約0.5秒)ごとに思考する
                this.thinkCooldown = this.thinkInterval;

                // ベクトルを再利用してパフォーマンス改善
                this._moveDirection = new THREE.Vector3();
                this._targetPosition = new THREE.Vector3(this.mesh.position.x, 0, 0); // 初期目標
                this._toMeVector = new THREE.Vector3();
                this._evasionDir = new THREE.Vector3();
                this._pos1 = new THREE.Vector3();
                this._pos2 = new THREE.Vector3();

                // 向きを常に左（プレイヤー側）に固定
                this.mesh.rotation.z = Math.PI / 2;
            }
            
            // ★AIの思考ルーチン
            think(player) {
                const myPos = this.mesh.position;
                const playerPos = player.mesh.position;

                // 状況評価
                const isMyHpLow = this.hp <= 3;
                const isMyAmmoLow = this.ammo <= 1;
                const isPlayerHpLow = player.hp <= 4;
                const hasEnoughAmmo = this.ammo >= 3;

                // 戦略決定
                let newState = 'STANDARD_ATTACK';
                if (isMyHpLow) {
                    newState = 'RETREATING';
                } else if (isMyAmmoLow) {
                    newState = 'FARMING_AMMO';
                } else if (isPlayerHpLow && hasEnoughAmmo) {
                    newState = 'AGGRESSIVE_ATTACK';
                }
                
                // 状態が切り替わったか、目標に到達したら新しい目標を設定
                if (this.aiState !== newState || myPos.distanceTo(this._targetPosition) < this.size) {
                    this.aiState = newState;
                    
                    const worldHeight = this.game.frustumSize / 2 - this.size;
                    const worldWidthHalf = (this.game.frustumSize * this.game.aspect / 2 - this.size) / 2;
                    
                    switch(this.aiState) {
                        case 'RETREATING':
                            // プレイヤーから最も遠いコートの隅を目指す
                            this._targetPosition.x = this.size;
                            this._targetPosition.y = (playerPos.y > 0 ? -1 : 1) * worldHeight;
                            break;
                            
                        case 'FARMING_AMMO':
                            // コート内をランダムに大きく動き回り、弾を補充
                            this._targetPosition.x = this.size + Math.random() * worldWidthHalf;
                            this._targetPosition.y = (Math.random() * 2 - 1) * worldHeight;
                            break;

                        case 'AGGRESSIVE_ATTACK':
                            // プレイヤーのY座標に直接合わせにいく
                            this._targetPosition.x = myPos.x;
                            this._targetPosition.y = playerPos.y;
                            break;

                        case 'STANDARD_ATTACK':
                            // プレイヤーのY座標を基準に、上下に揺さぶりをかける
                            this._targetPosition.x = myPos.x;
                            const randomOffsetY = (Math.random() * 60 - 30); // -30～+30のオフセット
                            this._targetPosition.y = THREE.MathUtils.clamp(playerPos.y + randomOffsetY, -worldHeight, worldHeight);
                            break;
                    }
                }
            }

            update(player, bullets) {
                this.updateSpeed();

                // --- 思考 ---
                this.thinkCooldown--;
                if (this.thinkCooldown <= 0) {
                    this.think(player);
                    this.thinkCooldown = this.thinkInterval + Math.floor(Math.random() * 15); // 少し間隔をランダムに
                }

                // --- 行動決定 ---
                this._moveDirection.set(0, 0, 0);
                
                // 1. 緊急回避 (最優先)
                const threateningBullet = this.findThreateningBullet(bullets);
                if (threateningBullet) {
                    this.getEvasionVector(threateningBullet, this._moveDirection);
                } else {
                // 2. 戦略に基づく行動
                    this._moveDirection.subVectors(this._targetPosition, this.mesh.position);
                    
                    // 攻撃判定
                    const isAttacking = this.aiState === 'AGGRESSIVE_ATTACK' || this.aiState === 'STANDARD_ATTACK';
                    if (isAttacking) {
                        // プレイヤーが射線上にいるか（Y座標がある程度近いか）
                        const yDiff = Math.abs(this.mesh.position.y - player.mesh.position.y);
                        if (yDiff < 15) { // 射線が合っていると判断する許容範囲
                             this.shoot();
                        }
                    }
                }
                
                // --- 実行 ---
                if (this._moveDirection.lengthSq() > 0) {
                    this._moveDirection.normalize().multiplyScalar(this.speed * 0.8);
                    this.mesh.position.add(this._moveDirection);
                    this.addAmmoOnMove(this._moveDirection.length());
                }

                this.keepInBounds();
            }
            
            findThreateningBullet(bullets) {
                let closestThreat = null;
                let minDistanceSq = 30 * 30; // 脅威とみなす範囲を少し広げる

                for (const bullet of bullets) {
                    if (bullet.owner === this) continue;

                    const distSq = bullet.mesh.position.distanceToSquared(this.mesh.position);
                    if (distSq < minDistanceSq) {
                        this._toMeVector.subVectors(this.mesh.position, bullet.mesh.position);
                        if (bullet.velocity.dot(this._toMeVector) > 0) { // 自分に向かっているか
                            minDistanceSq = distSq;
                            closestThreat = bullet;
                        }
                    }
                }
                return closestThreat;
            }
            
            getEvasionVector(bullet, outVector) {
                outVector.set(-bullet.velocity.y, bullet.velocity.x, 0); // 弾の進行方向と垂直
                this._pos1.copy(this.mesh.position).add(outVector);
                this._pos2.copy(this.mesh.position).sub(outVector);

                if (this._pos1.distanceToSquared(this.game.player.mesh.position) < this._pos2.distanceToSquared(this.game.player.mesh.position)) {
                    outVector.negate();
                }
                return outVector;
            }

            keepInBounds() {
                const worldWidth = this.game.frustumSize * this.game.aspect / 2 - this.size;
                const worldHeight = this.game.frustumSize / 2 - this.size;
                this.mesh.position.x = Math.max(0 + this.size, Math.min(worldWidth, this.mesh.position.x));
                this.mesh.position.y = Math.max(-worldHeight, Math.min(worldHeight, this.mesh.position.y));
            }
        }


        // ==================================================================
        // ===== Game Class (Main Controller) =============================
        // ==================================================================
        class Game {
            constructor() {
                this.scene = new THREE.Scene();
                this.aspect = window.innerWidth / window.innerHeight;
                this.frustumSize = 100;
                this.camera = new THREE.OrthographicCamera(
                    this.frustumSize * this.aspect / -2,
                    this.frustumSize * this.aspect / 2,
                    this.frustumSize / 2,
                    this.frustumSize / -2,
                    1,
                    1000
                );
                this.camera.position.z = 10;

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x1a1a1a);
                document.body.appendChild(this.renderer.domElement);
                
                this.player = null;
                this.enemy = null;
                this.bullets = [];

                this.playerHpUI = document.getElementById('player-hp');
                this.playerAmmoUI = document.getElementById('player-ammo');
                this.enemyHpUI = document.getElementById('enemy-hp');
                this.gameOverScreen = document.getElementById('game-over-screen');
                this.gameOverText = document.getElementById('game-over-text');
                this.restartButton = document.getElementById('restart-button');
                
                this.isGameOver = false;

                window.addEventListener('resize', this.onWindowResize.bind(this), false);
                this.restartButton.addEventListener('click', () => location.reload());
                document.body.addEventListener('keydown', this.firstInteraction.bind(this), { once: true });
            }

            firstInteraction() {
                initAudio();
                playSound('bgm');
            }

            start() {
                this.isGameOver = false;
                this.gameOverScreen.style.display = 'none';

                this.player = new Player(this.scene, this, new THREE.Vector3(-30, 0, 0), 0x00aaff);
                this.enemy = new Enemy(this.scene, this, new THREE.Vector3(30, 0, 0), 0xff4444);
                
                const grid = new THREE.GridHelper(this.frustumSize * 2, 20, 0x333333, 0x222222);
                grid.rotation.x = Math.PI / 2;
                this.scene.add(grid);

                const courtLineMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, linewidth: 2 });
                const points = [];
                const worldHeight = this.frustumSize / 2;
                points.push(new THREE.Vector3(0, -worldHeight, 0));
                points.push(new THREE.Vector3(0, worldHeight, 0));
                const courtLineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const courtLine = new THREE.Line(courtLineGeometry, courtLineMaterial);
                this.scene.add(courtLine);

                this.animate();
            }

            animate() {
                if (this.isGameOver) return;
                requestAnimationFrame(this.animate.bind(this));

                this.player.update();
                this.enemy.update(this.player, this.bullets);

                this.bullets.forEach(bullet => bullet.update());

                this.checkCollisions();
                this.updateUI();

                this.renderer.render(this.scene, this.camera);
            }
            
            checkCollisions() {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    if (bullet.owner !== this.player && bullet.mesh.position.distanceToSquared(this.player.mesh.position) < this.player.sizeSq) {
                        this.player.takeDamage(1);
                        playSound('hit');
                        bullet.removeFromScene();
                        this.bullets.splice(i, 1);
                        if (this.player.isDead()) this.endGame('YOU LOSE...');
                        continue;
                    }

                    if (bullet.owner !== this.enemy && bullet.mesh.position.distanceToSquared(this.enemy.mesh.position) < this.enemy.sizeSq) {
                        this.enemy.takeDamage(1);
                        playSound('hit');
                        bullet.removeFromScene();
                        this.bullets.splice(i, 1);
                        if (this.enemy.isDead()) this.endGame('YOU WIN!');
                    }
                }
            }

            endGame(message) {
                if (this.isGameOver) return;
                this.isGameOver = true;
                
                playSound('destroy');
                stopBGM();
                
                this.gameOverText.textContent = message;
                this.gameOverScreen.style.display = 'flex';

                if (message.includes('WIN')) {
                    this.enemy.destroy();
                } else {
                    this.player.destroy();
                }
            }

            updateUI() {
                this.playerHpUI.textContent = this.player.hp;
                this.playerAmmoUI.textContent = `${this.player.ammo} / ${this.player.maxAmmo}`;
                this.enemyHpUI.textContent = this.enemy.hp;
            }

            onWindowResize() {
                this.aspect = window.innerWidth / window.innerHeight;
                this.camera.left = this.frustumSize * this.aspect / -2;
                this.camera.right = this.frustumSize * this.aspect / 2;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // ==================================================================
        // ===== Main Execution ===========================================
        // ==================================================================
        window.addEventListener('DOMContentLoaded', () => {
            const game = new Game();
            game.start();
        });

    </script>
</body>
</html>