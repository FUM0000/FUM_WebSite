<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="author" content="F U M">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-B89KY0993B"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-B89KY0993B');
    </script>

    <link rel="shortcut icon" type="image/x-icon" href="../../Asset/Image/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../Asset/Image/Icon_1_2.jpg">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP:100,300,400,500,700,900&display=swap"
        rel="stylesheet">
    <link href="../../Asset/CSS/Game.css" rel="stylesheet" />

    <title>Space Ship</title>

    <style>
        #Fade_Game {
            background-color: #222222 !important;
        }
    </style>
</head>

<body>

    <div id="Joystick" class="Joystick_Area"></div>
    <div id="Fade_Game"></div>
    <canvas id="Canvas"></canvas>

    <style>
        .Joystick_Area {
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            touch-action: none;
        }
    </style>

    <script src="https://code.jquery.com/jquery-3.3.1.js"></script>

    <script type="module">

        // Setup Threejs
        import * as THREE from 'https://unpkg.com/three@0.126.1/build/three.module.js';
        import { FBXLoader } from "https://unpkg.com/three@0.126.1/examples/jsm/loaders/FBXLoader.js";
        import {
            Mobile_or_Desktop,
            RandomNumber_Between,
            Shousuu_Kirisute,
            Radians_to_Degrees,
            Alpha_Change,
            FC_JoystickController,
            FC_Input_Keyboard,
            FC_GameObject,
            FC_Environment,
            FC_Animation,
            FC_Camera,
            FC_Camera_Controller,
            FC_Light_Ambient,
            FC_Light_Directional,
            FC_Timer,
            FC_Audio,
            FC_TextPlane,
            FC_ImagePlane,
            FC_Player_Controller,
            FC_Manager,
        } from "../../Asset/Javascript/Game.js";
        const Scene = new THREE.Scene();
        const Renderer = new THREE.WebGLRenderer({ canvas: document.querySelector("#Canvas"), antialias: true });
        Scene.fog = new THREE.Fog(0x222222, 0, 50);
        Renderer.setPixelRatio(window.devicePixelRatio);
        Renderer.setSize(window.innerWidth, window.innerHeight);
        Renderer.setClearColor(new THREE.Color(0x222222));
        const Loader_FBX = new FBXLoader();
        if (Mobile_or_Desktop()) document.addEventListener('touchstart', function () { TouchStart(event); });
        else document.addEventListener('mousedown', function () { TouchStart(event); });

        class C_Manager extends FC_Manager {

            _JOYSTICK = new FC_JoystickController(document.getElementById("Joystick"));
            _SENSIVILITY = 0.0001;
            _Input_Keyboard = new FC_Input_Keyboard();

            _UI_Home = new FC_TextPlane(Scene, Camera, "HOME", "#CF0000", new THREE.Vector2(4, 1).multiplyScalar(FC_Manager.UI_SIZE_MULTIPLY));
            _UI_Music = new FC_TextPlane(Scene, Camera, "MUSIC", "#CF0000", new THREE.Vector2(4, 1).multiplyScalar(FC_Manager.UI_SIZE_MULTIPLY));
            _UI_Start = new FC_TextPlane(Scene, Camera, "START", "#CF0000", new THREE.Vector2(5, 1).multiplyScalar(FC_Manager.UI_SIZE_MULTIPLY));
            _UI_Gameover = new FC_TextPlane(Scene, Camera, "GAMEOVER", "#CF000000", new THREE.Vector2(8, 1).multiplyScalar(FC_Manager.UI_SIZE_MULTIPLY));
            _UI_Tap = new FC_TextPlane(Scene, Camera, "TAP", "#CF000000", new THREE.Vector2(3, 1).multiplyScalar(FC_Manager.UI_SIZE_MULTIPLY));


            _energyAreaManager = new C_EnergyAreaManager();
            _energyMeter = new C_EnergyMeter(Scene, Camera);


            get UI_Home() { return this._UI_Home; }
            get UI_Music() { return this._UI_Music; }

            constructor() {
                super(Scene, Renderer);
            }

            Initialize() {
                super.Initialize();

                Player.Initialize();
                Camera.Initialize();
                Camera.Target = Player;

                this._UI_Home.Initialize();
                this._UI_Home.Fog = false;
                this._UI_Music.Initialize();
                this._UI_Music.Fog = false;

                this._UI_Start.Initialize();
                this._UI_Start.Position = new THREE.Vector3(0, 0.5, -8);
                this._UI_Gameover.Initialize();
                this._UI_Gameover.Position = new THREE.Vector3(0, 0, -8);
                this._UI_Tap.Initialize();
                this._UI_Tap.Fog = true;
                this._UI_Tap.Position = new THREE.Vector3(0, -0.25, -8);
                this._UI_Tap.Rotation = new THREE.Vector3(0, 0, THREE.MathUtils.degToRad(180));

                this._energyMeter.Initialize();

                if (this._State == "Before_Loaded") {
                    this.BGM = '../../Asset/Audio/wave_1.wav';
                    this.BGM.Volume = 0.2;
                    Scene.fog = new THREE.Fog(0x222222, 0, 0);
                    this._UI_Tap.Fog = false;
                    this._UI_Tap.Show();
                    const direction = new THREE.Vector3();
                    Camera.Object.getWorldDirection(direction);
                    this._UI_Tap.Position = Camera.Position.clone().add(direction.multiplyScalar(2));
                    this._UI_Tap.LookAt(Camera.Position);
                }
            }
            Update() {

                if (this._State == "Before_Loaded") {
                    this._State = "Loaded"
                    super.Fade(true);
                }
                if (this._State != "Before_Loaded") {
                    this._Input_Move = this._JOYSTICK.getInput();

                    switch (this._State) {
                        case "Waiting":
                            this._Timer_Waiting.Update();
                            if (this._Timer_Waiting.Flag_Finished) {
                                this._State = "Waiting_Start";
                                this._UI_Tap.Show();
                            }
                            break;
                        case "Playing": Manager.Update_Playing(); break;
                    }
                    Manager.Update_System();

                }
                Renderer.render(Scene, Camera.Object);
                requestAnimationFrame(this.Update.bind(this));
            }
            Update_System() {
                this._Timer_Input.Update();

                if (this._State == "Gameover") {
                    this._Timer_Ready += FC_Environment.TIME_DELTA;
                    if (this._Timer_Ready > this._TIME_FOR_READY) {
                        this._State = "Waiting_Restart";
                        this._UI_Tap.Position = new THREE.Vector3(Camera.Position_LookAt.x, Camera.Position_LookAt.y - 0.25, -8);
                    }
                }

                const cameraQuaternion = new THREE.Quaternion();
                Camera.Object.getWorldQuaternion(cameraQuaternion);
                const tiltQuaternion_y = new THREE.Quaternion();
                const tiltQuaternion_x = new THREE.Quaternion();
                tiltQuaternion_y.setFromAxisAngle(new THREE.Vector3(0, 1, 0), THREE.MathUtils.degToRad(-30));
                tiltQuaternion_x.setFromAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(30));
                cameraQuaternion.multiply(tiltQuaternion_y);
                cameraQuaternion.multiply(tiltQuaternion_x);

                this._UI_Home.Place_on_Screen(new THREE.Vector2(0.6, 0.8), 4);
                this._UI_Home.Rotation_Quaternion = cameraQuaternion;
                this._UI_Music.Place_on_Screen(new THREE.Vector2(0.6, 0.7), 4);
                this._UI_Music.Rotation_Quaternion = cameraQuaternion;
            }
            Update_Playing() {
                if (this._Input_Move.length() == 0) {
                    this._Input_Move = this._Input_Keyboard.Input_Move;
                }
                if (this._Input_Move.length() > 0) this._Input_Move.normalize();
                Player.Update(this._Input_Move);
                Camera.Update();

                this._UI_Start.Update();
                this._UI_Tap.Update();


                // エネルギーエリアマネージャーの更新
                this._energyAreaManager.Update();

                // プレイヤーがいずれかのエリア内にいる場合、エネルギーを回復
                if (this._energyAreaManager.Check(Player.Position)) {
                    Player.CollectEnergy();
                }


                // エネルギーメーターの更新
                this._energyMeter.Update(Player.CarbonEnergy);
            }

            Start() {
                super.Start();
                this._UI_Start.Animation_Move(new THREE.Vector3(0, 1, 0), 1);
                this._UI_Tap.Animation_Move(new THREE.Vector3(0, -1, 0), 1);
            }
            GameOver() {
                super.GameOver();
                this._UI_Gameover.Position = new THREE.Vector3(Camera.Position_LookAt.x, Camera.Position_LookAt.y + 0.5, -8);
                this._UI_Gameover.Show();
            }

            Set_Tap() {
                this._UI_Tap.Initialize();
                this._UI_Tap.Fog = true;
                this._UI_Tap.Position = new THREE.Vector3(0, -0.25, -8);
                this._UI_Tap.Rotation = new THREE.Vector3(0, 0, THREE.MathUtils.degToRad(180));
            }
        }

        class C_Player extends FC_GameObject {

            _Speed_Past;
            _Speed;
            _Speed_Acceleration;

            constructor() {
                super();
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 3);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.x = 0.5;
                this._Object = mesh;
                Scene.add(this._Object);
                
                this.Initialize();
            }

            Initialize() {
                this._Speed_Past = 1.2;
                this._Speed = this._Speed_Past;
                this._Speed_Acceleration = 1;

                this.Position = new THREE.Vector3(0, 0, 0);
                this.Rotation = new THREE.Vector3(Math.PI / 2, Math.PI, 0);

                this._carbonEnergy = 100;
                this._maxCarbonEnergy = 100;
                this._energyDecreaseRate = 5;
            }
            Update(_input) {
                if (_input && _input.length() != 0) {
                    const direction = new THREE.Vector3(-_input.x, _input.y, 0).normalize();
                    this.Move(direction.clone().multiplyScalar(this._Speed * FC_Environment.TIME_DELTA));
                    this._Object.rotation.y = Math.atan2(direction.y, direction.x) + Math.PI / 2;

                    // エネルギーを徐々に減少
                    this._carbonEnergy = Math.max(0, this._carbonEnergy - this._energyDecreaseRate * FC_Environment.TIME_DELTA);

                    // エネルギーが0になったらゲームオーバー
                    if (this._carbonEnergy <= 0) {
                        Manager.GameOver();
                    }
                }
            }

            Move(_vector3) {
                this._Object.position.add(_vector3);
            }


            get CarbonEnergy() { return this._carbonEnergy; }

            CollectEnergy() {
                const recoveryRate = this._maxCarbonEnergy * 0.5;
                this._carbonEnergy = Math.min(this._maxCarbonEnergy, this._carbonEnergy + recoveryRate * FC_Environment.TIME_DELTA);
            }
        }

        class C_EnergyAreaManager {

            static NUMBER_RING = 5;
            static NUMBER_PER_RING = 5;
            static RADIUS = 15;

            _Array = [];

            constructor() {
                this.Generate();
            }

            Generate() {
                for (let r = 1; r <= C_EnergyAreaManager.NUMBER_RING; r++) {
                    const currentRadius = C_EnergyAreaManager.RADIUS * r;
                    let angle = Math.random() * Math.PI * 2;
                    for (let i = 0; i < C_EnergyAreaManager.NUMBER_PER_RING; i++) {
                        angle = angle + THREE.MathUtils.degToRad(360 / C_EnergyAreaManager.NUMBER_PER_RING);
                        const x = Math.cos(angle) * currentRadius;
                        const y = Math.sin(angle) * currentRadius;
                        this.Create(new THREE.Vector3(x, y, 0));
                    }
                }
            }

            Create(position) {
                const area = new C_EnergyArea(position);
                this._Array.push(area);
            }

            Update() {
                this._Array.forEach(area => area.Update());
            }

            Check(_position) {
                for (const area of this._Array) {
                    if (area.Check(_position)) {
                        return true;
                    }
                }
                return false;
            }
        }
        
        class C_EnergyArea extends FC_GameObject {

            static RADIUS = 2;
            static SPEED_ROTATION = Math.PI / 6;

            _Object_Back = null;
            _Object_Wire = null;

            constructor(_position) {
                super();
                const geometry_back = new THREE.CylinderGeometry(C_EnergyArea.RADIUS, C_EnergyArea.RADIUS, 0.1, 32);
                const material_back = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.3
                });
                this._Object_Back = new THREE.Mesh(geometry_back, material_back);
                this._Object_Back.position.copy(_position);
                this._Object_Back.rotation.set(THREE.MathUtils.degToRad(90), 0, 0);
                Scene.add(this._Object_Back);

                const geometry_wire = new THREE.CylinderGeometry(C_EnergyArea.RADIUS, C_EnergyArea.RADIUS, 0.1, 32);
                const material_wire = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    wireframe: true
                });
                this._Object_Wire = new THREE.Mesh(geometry_wire, material_wire);
                this._Object_Wire.position.copy(this._Object_Back.position);
                this._Object_Wire.rotation.copy(this._Object_Back.rotation);
                Scene.add(this._Object_Wire);
            }

            get Position() {
                return this._Object_Back.position;
            }

            Update() {
                this._Object_Wire.rotation.y += C_EnergyArea.SPEED_ROTATION * FC_Environment.TIME_DELTA;
            }

            Check(_position) {
                const distance = new THREE.Vector2(
                    _position.x - this._Object_Wire.position.x,
                    _position.y - this._Object_Wire.position.y
                ).length();
                return distance < C_EnergyArea.RADIUS;
            }
        }

        class C_EnergyMeter extends FC_GameObject {

            _Camera = null;

            constructor(_scene, _camera) {
                super();
                this._textPlane = new FC_TextPlane(
                    _scene,
                    _camera,
                    "ENERGY: 100%",
                    "#00FF88",
                    new THREE.Vector2(8, 1).multiplyScalar(FC_Manager.UI_SIZE_MULTIPLY)
                );
                this._Camera = _camera;
            }

            Initialize() {
                this._textPlane.Initialize();
            }

            Update(_energy) {
                const percentage = Math.round((_energy / 100) * 100);
                this._textPlane.Text = `ENERGY: ${percentage}%`;

                this._textPlane.Place_on_Screen(new THREE.Vector2(-0.5, 0.7), 4);
                const quaternion = new THREE.Quaternion();
                this._Camera.Object.getWorldQuaternion(quaternion);
                const quaternion_y = new THREE.Quaternion();
                const quaternion_x = new THREE.Quaternion();
                quaternion_y.setFromAxisAngle(new THREE.Vector3(0, 1, 0), THREE.MathUtils.degToRad(30));
                quaternion_x.setFromAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(30));
                quaternion.multiply(quaternion_y);
                quaternion.multiply(quaternion_x);
                this._textPlane.Rotation_Quaternion = quaternion;
            }
        }



        const Environment = new FC_Environment();
        const Camera = new FC_Camera(Renderer, undefined, new THREE.Vector3(0, 0, -10));
        const Light_Ambient = new FC_Light_Ambient(Scene);
        const Light_Directional = new FC_Light_Directional(Scene);
        window.addEventListener('resize', Camera.Resize_Screen, false);

        const Manager = new C_Manager();
        const Player = new C_Player();

        Manager.Initialize();
        Manager.Update();

        function TouchStart(event) {
            if (Manager.Timer_Input.Flag_Finished) {

                let screen_x, screen_y;
                switch (event.type) {
                    case "touchstart":
                        screen_x = event.touches[0].clientX;
                        screen_y = event.touches[0].clientY;
                        break;
                    case "mousedown":
                        screen_x = event.clientX;
                        screen_y = event.clientY;
                        break;
                }

                const screen_position = new THREE.Vector2(
                    (screen_x / window.innerWidth) * 2 - 1,
                    -(screen_y / window.innerHeight) * 2 + 1
                );
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(screen_position, Camera.Object);

                const ui_home = raycaster.intersectObject(Manager.UI_Home.Mesh_Front);
                if (ui_home.length > 0) { window.location.href = "./index.html"; return; }
                const ui_music = raycaster.intersectObject(Manager.UI_Music.Mesh_Front);
                if (ui_music.length > 0) { Manager.BGM.Flag_Playing ? Manager.BGM.Stop() : Manager.BGM.Play(); return; }

                switch (Manager.State) {
                    case "Loaded":
                        Scene.fog = new THREE.Fog(0x222222, 0, 50);
                        Manager.Set_Tap();
                        Manager.Change_State("Waiting");
                        break;
                    case "Waiting_Start": Manager.Start(); break;
                    case "Playing": break;
                    case "Waiting_Restart":
                        Manager.Fade(false);
                        setTimeout(() => {
                            Manager.Initialize();
                            Manager.Change_State("Waiting");
                            Manager.Fade(true);
                        }, 1000);
                        break;
                }
                Manager.Timer_Input.Restart();
            }
        }
    </script>

</body>

</html>