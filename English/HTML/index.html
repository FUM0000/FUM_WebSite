<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="author" content="F U M">
    <meta name="description" content="FUM_Website">
    <meta name="robots" content="index, follow">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-B89KY0993B"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-B89KY0993B');
    </script>
    <link rel="canonical" href="https://fum0000.github.io/FUM_WebSite/English/HTML/index.html">

    <link rel="icon" type="image/x-icon" href="../../Asset/Image/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../Asset/Image/Icon_1_2.jpg">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP:100,300,400,500,700,900&display=swap"
        rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@7.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="../../Asset/CSS/Common.css?v=1.0" rel="stylesheet" />
    <link href="../../Asset/CSS/Index.css?v=1.0" rel="stylesheet" />

    <title>FUM_Website</title>

    <style>
        .speech-bubble {
            position: absolute;
            background: rgba(30, 30, 30, 0.85);
            border: 1px solid #00ffcc;
            border-radius: 10px;
            padding: 10px 15px;
            color: #00ffcc;
            font-family: 'Noto Sans JP', sans-serif;
            font-weight: 500;
            z-index: 5;
            pointer-events: none;
            transform: translate(-50%, -130%);
            white-space: nowrap;
            transition: opacity 0.3s ease-in-out, top 0.1s linear, left 0.1s linear;
            opacity: 0;
        }

        .speech-bubble.show {
            opacity: 1;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid rgba(30, 30, 30, 0.85);
        }
    </style>
</head>

<body>
    <canvas id="ElectronShell"></canvas>
    <v-app id="App">
        <template>
            <main-system-bar :drawer="Drawer" @change-drawer="ChangeDrawer">Home</main-system-bar>

            <v-main id="Main">
                <transition name="Fade_Page">
                    <v-container v-show="Ready_Page" fluid fill-height class="pa-5" style="align-content: flex-start;">
                        <v-container id="TextFlow">
                            <span style="color: red"> &lt;NEWS&gt; </span>
                            <span style="color: rgb(200, 200, 200)">
                                June to July is the rainy season! Humid air sweeps across Japan. Umbrellas and raincoats
                                are a must! Watch out for food poisoning and flooding.
                            </span>
                        </v-container>
                    </v-container>
                </transition>
            </v-main>

            <div :class="['speech-bubble', { 'show': ShowMessage }]" :style="MessageStyle">
                {{ CurrentMessage }}
            </div>

            <main-navigation :drawer="Drawer" @change-drawer="ChangeDrawer"></main-navigation>
            <main-footer-simple></main-footer-simple>
        </template>
    </v-app>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.js"></script>
    <script src="../../Asset/Javascript/Common.js?v=1.0"></script>
    <script src="../../Asset/Javascript/Index.js?v=1.0"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js" defer></script>

    <script>
        window.vue = new Vue({
            el: '#App',
            vuetify: new Vuetify(),
            mixins: [window.Mixins_Common, window.Mixins_Index],
            data: {
                ShowMessage: false,
                CurrentMessage: '',
                MessageStyle: { top: '0px', left: '0px' }
            },
        })
    </script>

    <script type="module">
        const vue = window.vue;
        const isMobile = window.innerWidth <= 768;
        let textMeshMouthClosed, textMeshMouthOpen;

        const fireworks = [];
        const gravity = new THREE.Vector3(0, -0.02, 0);
        const fireworkTypes = ['peony', 'chrysanthemum', 'crown', 'thousand-wheels', 'shape-heart', 'shape-star', 'shape-saturn', 'willow', 'bouquet', 'nishaku-dama', 'bun-pou'];
        let fireworksEnabled = false; // カメラアニメーション後に花火を有効にするフラグ
        const MAX_FIREWORKS = isMobile ? 5 : 10; // 花火の最大同時表示数

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x020202, 0, 5000);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector("#ElectronShell"),
            antialias: true
        });
        renderer.setClearColor(0x010104, 1);
        renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.5;


        function generateNoiseTexture(width = 256, height = 256) {
            const size = width * height;
            const data = new Uint8Array(size * 4);
            for (let i = 0; i < size; i++) {
                const value = Math.random() * 255;
                data[i * 4] = value;
                data[i * 4 + 1] = value;
                data[i * 4 + 2] = value;
                data[i * 4 + 3] = 255;
            }
            const texture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.needsUpdate = true;
            return texture;
        }

        const voidTexture = generateNoiseTexture();
        const voidBackground = new THREE.Mesh(
            new THREE.SphereGeometry(3000, 16, 16),
            new THREE.MeshBasicMaterial({
                map: voidTexture,
                side: THREE.BackSide,
                opacity: 0.2,
                transparent: true,
                color: 0x020206,
                fog: false
            })
        );
        scene.add(voidBackground);

        // パーティクル用のテクスチャ
        function createCircleTexture() {
            const size = 16; // 解像度を最低限に
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size / 2;
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
            context.fillStyle = '#FFFFFF';
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createCircleTexture();

        const loader = new THREE.FontLoader();
        loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
            const textGeometry1 = new THREE.TextGeometry('^. .^', {
                font: font,
                size: 2,
                height: 0.25,
                curveSegments: 2,
                bevelEnabled: true,
                bevelThickness: 0,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 0
            });

            const textGeometryMouthClosed = new THREE.TextGeometry('-', {
                font: font,
                size: 1,
                height: 0.25,
                curveSegments: 2,
                bevelEnabled: true,
                bevelThickness: 0,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 0
            });

            const textGeometryMouthOpen = new THREE.TextGeometry('o', {
                font: font,
                size: 1,
                height: 0.25,
                curveSegments: 2,
                bevelEnabled: true,
                bevelThickness: 0,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 0
            });

            const textMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ff00,
                emissive: 0x00ffcc,
                emissiveIntensity: 0.5,
                shininess: 100,
                fog: false
            });

            const textMesh1 = new THREE.Mesh(textGeometry1, textMaterial);
            textMeshMouthClosed = new THREE.Mesh(textGeometryMouthClosed, textMaterial);
            textMeshMouthOpen = new THREE.Mesh(textGeometryMouthOpen, textMaterial);

            textGeometry1.computeBoundingBox();
            const textWidth1 = textGeometry1.boundingBox.max.x - textGeometry1.boundingBox.min.x;
            textMesh1.position.set(-textWidth1 / 2 - 0.35, 0, 0);

            textGeometryMouthClosed.computeBoundingBox();
            const textWidthClosed = textGeometryMouthClosed.boundingBox.max.x - textGeometryMouthClosed.boundingBox.min.x;
            textMeshMouthClosed.position.set(-textWidthClosed / 2 - 0.1, -1, 0);

            textGeometryMouthOpen.computeBoundingBox();
            const textWidthOpen = textGeometryMouthOpen.boundingBox.max.x - textGeometryMouthOpen.boundingBox.min.x;
            textMeshMouthOpen.position.set(-textWidthOpen / 2 - 0.025, -0.5, 0); // 口を開いたように少し下に配置

            textMeshMouthOpen.visible = false; // 初期状態は非表示

            scene.add(textMesh1);
            scene.add(textMeshMouthClosed);
            scene.add(textMeshMouthOpen);

            const light = new THREE.PointLight(0x00ffcc, 1);
            light.position.set(0, 0, 5);
            scene.add(light);
        });

        function createProceduralCubeMap() {
            const size = 64;
            const images = [];
            for (let i = 0; i < 6; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
                gradient.addColorStop(0, 'rgba(8, 25, 45, 255)');
                gradient.addColorStop(1, 'rgba(1, 3, 8, 255)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                images.push(canvas);
            }
            const cubeTexture = new THREE.CubeTexture(images);
            cubeTexture.format = THREE.RGBAFormat;
            cubeTexture.needsUpdate = true;
            return cubeTexture;
        }

        const envMap = createProceduralCubeMap();

        const liquidSphereGeometry = new THREE.SphereGeometry(3, 128, 128);
        const liquidShaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                baseColor: { value: new THREE.Color(0x0077cc) },
                envMap: { value: envMap },
                viewPos: { value: camera.position },
                cameraDistance: { value: 0.0 },
                noiseScale: { value: 0.8 },
                noiseStrength: { value: 0.1 },
                flowSpeed: { value: 0.3 },
                fresnelPower: { value: 3.0 },
                fresnelScale: { value: 1.2 },
                fresnelBias: { value: 0.05 },
                specularStrength: { value: 0.15 },
                shininess: { value: 40.0 },
                scatteringStrength: { value: 1 },
                rimPower: { value: 2.5 },
                rimStrength: { value: 0.2 },
                rimColor: { value: new THREE.Color(0x00ccff) }
            },
            vertexShader: `
            varying vec3 vNormal;
            varying vec3 vWorldPosition;
            varying vec3 vViewPosition;
            uniform float time;
            uniform float noiseScale;
            uniform float noiseStrength;
            uniform float flowSpeed;

            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(
                          i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            vec3 curlNoise(vec3 p) {
                const float e = 0.1;
                vec3 dx = vec3(e, 0.0, 0.0);
                vec3 dy = vec3(0.0, e, 0.0);
                vec3 dz = vec3(0.0, 0.0, e);

                float n0 = snoise(p);
                float n1 = snoise(p + dx);
                float n2 = snoise(p - dx);
                float n3 = snoise(p + dy);
                float n4 = snoise(p - dy);
                float n5 = snoise(p + dz);
                float n6 = snoise(p - dz);

                float dNdx = (n1 - n2) / (2.0 * e);
                float dNdy = (n3 - n4) / (2.0 * e);
                float dNdz = (n5 - n6) / (2.0 * e);

                vec3 curl;
                curl.x = dNdy - dNdz;
                curl.y = dNdz - dNdx;
                curl.z = dNdx - dNdy;

                return normalize(curl);
            }

            void main() {
                vec3 pos = position;
                vec3 noisePos = pos * noiseScale + time * flowSpeed;
                vec3 curl = curlNoise(noisePos);
                pos += curl * noiseStrength;
                vNormal = normalize(normalMatrix * (normal + curl * noiseStrength));
                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vWorldPosition = worldPosition.xyz;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
            fragmentShader: `
            uniform float time;
            uniform vec3 baseColor;
            uniform samplerCube envMap;
            uniform vec3 viewPos;
            uniform float cameraDistance;
            uniform float fresnelPower;
            uniform float fresnelScale;
            uniform float fresnelBias;
            uniform float specularStrength;
            uniform float shininess;
            uniform float scatteringStrength;
            uniform float rimPower;
            uniform float rimStrength;
            uniform vec3 rimColor;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;
            varying vec3 vViewPosition;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(viewPos - vWorldPosition);
                float distanceFactor = clamp(8.0 / cameraDistance, 0.3, 1.0);
                float fresnel = fresnelBias + fresnelScale * pow(1.0 - max(dot(normal, viewDir), 0.0), fresnelPower);
                fresnel *= distanceFactor;
                float rim = rimStrength * pow(1.0 - max(dot(normal, viewDir), 0.0), rimPower);
                rim *= distanceFactor;
                vec3 reflectDir = reflect(-viewDir, normal);
                vec3 reflection = textureCube(envMap, reflectDir).rgb;
                reflection *= distanceFactor;
                vec3 lightDir = normalize(vec3(5.0, 5.0, 5.0));
                vec3 halfwayDir = normalize(lightDir + viewDir);
                float spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);
                vec3 specular = specularStrength * spec * vec3(1.0);
                specular *= distanceFactor;
                float scatter = scatteringStrength * (1.0 - max(dot(normal, viewDir), 0.0));
                vec3 color = baseColor + reflection * fresnel + specular;
                color += vec3(0.1, 0.2, 0.3) * scatter;
                color += rim * rimColor;
                float alpha = 0.25;
                gl_FragColor = vec4(color, alpha);
            }
        `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const liquidSphere = new THREE.Mesh(liquidSphereGeometry, liquidShaderMaterial);
        liquidSphere.position.set(0, 0, 0);
        liquidSphere.scale.set(0.9, 0.9, 0.9);
        liquidSphere.castShadow = false;
        liquidSphere.receiveShadow = false;
        scene.add(liquidSphere);

        const glassSphereGeometry = new THREE.SphereGeometry(3.5, 64, 64);
        const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.1,
            roughness: 0.05,
            envMap: envMap,
            envMapIntensity: 1.0,
            transparent: true,
            opacity: 0.2,
            premultipliedAlpha: true,
            depthWrite: false,
            side: THREE.FrontSide
        });
        const glassSphere = new THREE.Mesh(glassSphereGeometry, glassMaterial);
        scene.add(glassSphere);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 0.8;
        controls.enablePan = false;
        controls.maxPolarAngle = Math.PI - 0.1;
        controls.minPolarAngle = 0.1;

        camera.position.copy(new THREE.Vector3(0, 1, 0).multiplyScalar(10000));
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        function easeInOutSloMo(t) {
            return Math.pow(easeInOutCubic(t), 2);
        }

        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const intersectionPoint = new THREE.Vector3();

        const cursorParticles = [];
        const cursorParticleGeometry = new THREE.BufferGeometry();
        // 修正: emissiveとemissiveIntensityを削除
        const cursorParticleMaterial = new THREE.PointsMaterial({
            color: 0x00ffcc,
            size: 0.1,
            transparent: true,
            opacity: 0.8,
        });

        const electronShells = [
            { name: 'K', electrons: 2, radius: 5 },
            { name: 'L', electrons: 8, radius: 8 },
            { name: 'M', electrons: 18, radius: 11 },
            { name: 'N', electrons: 32, radius: 14 },
            { name: 'O', electrons: 32, radius: 17 }
        ];

        const totalElectrons = electronShells.reduce((sum, shell) => sum + shell.electrons, 0);
        const pointSize = 0.25;
        const connectionDistance = 4.5;
        const avoidanceDistance = 1.2;
        const repulsionStrength = 0.02;

        const pointMaterial = new THREE.PointsMaterial({
            color: 0x00ffcc,
            size: pointSize,
            fog: false
        });

        const positions = new Float32Array(totalElectrons * 3);
        const velocities = new Float32Array(totalElectrons * 3);

        const ALPHA = 1 / 137;
        const LIGHT_SPEED = 0.299792458;

        let currentIndex = 0;
        electronShells.forEach((shell, shellIndex) => {
            const baseSpeed = (92 * ALPHA * LIGHT_SPEED / (shellIndex + 1)) * 2;
            for (let i = 0; i < shell.electrons; i++) {
                const golden_ratio = (1 + Math.sqrt(5)) / 2;
                const theta = 2 * Math.PI * i / golden_ratio;
                const phi = Math.acos(1 - 2 * (i + 0.5) / shell.electrons);

                const x = shell.radius * Math.sin(phi) * Math.cos(theta);
                const y = shell.radius * Math.sin(phi) * Math.sin(theta);
                const z = shell.radius * Math.cos(phi);

                positions[currentIndex * 3] = x;
                positions[currentIndex * 3 + 1] = y;
                positions[currentIndex * 3 + 2] = z;

                const tangentX = -Math.sin(theta);
                const tangentY = Math.cos(theta);
                const tangentZ = 0;

                velocities[currentIndex * 3] = tangentX * baseSpeed;
                velocities[currentIndex * 3 + 1] = tangentY * baseSpeed;
                velocities[currentIndex * 3 + 2] = tangentZ * baseSpeed;

                currentIndex++;
            }
        });

        const pointGeometry = new THREE.BufferGeometry();
        pointGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const pointCloud = new THREE.Points(pointGeometry, pointMaterial);
        scene.add(pointCloud);

        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.2,
            fog: false
        });

        let lineSegments;
        if (!isMobile) {
            const lineGeometry = new THREE.BufferGeometry();
            lineSegments = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(lineSegments);
        }

        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight));
        bloomPass.threshold = 0;
        // パフォーマンス向上のためBloom効果をさらに調整
        if (isMobile) {
            bloomPass.strength = 0.6; // ぼやけを軽減
            bloomPass.radius = 0.1;   // ぼやけを軽減
        } else {
            bloomPass.strength = 0.8; // 負荷軽減のため少し下げる
            bloomPass.radius = 0.6;
        }
        composer.addPass(bloomPass);

        const DigitalGlitchShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'tDisp': { value: null },
                'byp': { value: 0 },
                'amount': { value: 0.08 },
                'angle': { value: 0.02 },
                'seed': { value: 0.02 },
                'seed_x': { value: 0.02 },
                'seed_y': { value: 0.02 },
                'distortion_x': { value: 0.5 },
                'distortion_y': { value: 0.6 },
                'col_s': { value: 0.05 }
            },
            vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
            fragmentShader: `
        uniform int byp;
        uniform sampler2D tDiffuse;
        uniform sampler2D tDisp;
        uniform float amount;
        uniform float angle;
        uniform float seed;
        float seed_x;
        uniform float seed_y;
        uniform float distortion_x;
        uniform float distortion_y;
        uniform float col_s;
        varying vec2 vUv;

        float rand(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            if (byp < 1) {
                vec2 p = vUv;
                if (amount > 0.0) {
                    float xs = floor(gl_FragCoord.x / 0.5);
                    float ys = floor(gl_FragCoord.y / 0.5);
                    vec4 normal = texture2D(tDisp, p * seed * seed);
                    if (p.y < distortion_x + col_s && p.y > distortion_x - col_s * seed) {
                        if (seed_x > 0.0) {
                            p.y = 1.0 - (p.y + distortion_y);
                        } else {
                            p.y = distortion_y;
                        }
                    }
                    if (p.x < distortion_y + col_s && p.x > distortion_y - col_s * seed) {
                        if (seed_y > 0.0) {
                            p.x = distortion_x;
                        } else {
                            p.x = 1.0 - (p.x + distortion_x);
                        }
                    }
                    p.x += normal.x * seed_x * (seed / 5.0);
                    p.y += normal.y * seed_y * (seed / 5.0);
                    vec2 offset = amount * vec2(cos(angle), sin(angle));
                    vec4 cr = texture2D(tDiffuse, p + offset);
                    vec4 cga = texture2D(tDiffuse, p);
                    vec4 cb = texture2D(tDiffuse, p - offset);
                    gl_FragColor = vec4(cr.r, cga.g, cb.b, 1.0);
                } else {
                    gl_FragColor = texture2D(tDiffuse, p);
                }
            } else {
                gl_FragColor = texture2D(tDiffuse, vUv);
            }
        }
    `
        };

        function generateNoiseTextureForGlitch(size = 64) {
            const data = new Uint8Array(size * size * 4);
            for (let i = 0; i < size * size * 4; i++) {
                data[i] = Math.random() * 255;
            }
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.needsUpdate = true;
            return texture;
        }

        let glitchPass;
        if (!isMobile) {
            glitchPass = new THREE.ShaderPass(DigitalGlitchShader);
            glitchPass.uniforms.tDisp.value = generateNoiseTextureForGlitch();
            glitchPass.renderToScreen = true;
            composer.addPass(glitchPass);
        } else {
            bloomPass.renderToScreen = true;
        }

        let isGlitching = false;
        let glitchTimeout;

        function updateGlitch() {
            if (isGlitching) {
                glitchPass.uniforms.seed.value = Math.random();
                glitchPass.uniforms.amount.value = Math.random() * 0.1 + 0.02;
                glitchPass.uniforms.angle.value = Math.random() * 2;
                glitchPass.uniforms.seed_x.value = (Math.random() > 0.5 ? 0.02 : -0.02);
                glitchPass.uniforms.seed_y.value = (Math.random() > 0.5 ? 0.02 : -0.02);
                glitchPass.uniforms.distortion_x.value = Math.random() * 0.5;
                glitchPass.uniforms.distortion_y.value = Math.random() * 0.5;
                glitchPass.uniforms.col_s.value = Math.random() * 0.05;
            } else {
                glitchPass.uniforms.amount.value = 0;
            }
        }

        function triggerGlitch() {
            isGlitching = true;
            clearTimeout(glitchTimeout);
            const duration = (Math.random() - 0.5) * 500;
            glitchTimeout = setTimeout(() => {
                isGlitching = false;
            }, duration);
            const nextTrigger = Math.random() * 5000 + 3000;
            setTimeout(triggerGlitch, nextTrigger);
        }

        if (!isMobile) {
            setTimeout(triggerGlitch, 2000);
        }

        function createCursorParticle(x, y, z) {
            for (let i = 0; i < 1; i++) {
                const speed = 0.05;
                const particle = {
                    position: new THREE.Vector3(x, y, z),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * speed,
                        (Math.random() - 0.5) * speed,
                        (Math.random() - 0.5) * speed
                    ),
                    life: 1.0
                };
                cursorParticles.push(particle);
            }
        }

        function updateCursorParticles() {
            for (let i = cursorParticles.length - 1; i >= 0; i--) {
                const particle = cursorParticles[i];
                particle.position.add(particle.velocity);
                particle.life -= 0.01;
                if (particle.life <= 0) {
                    cursorParticles.splice(i, 1);
                }
            }
            const positions = new Float32Array(cursorParticles.length * 3);
            cursorParticles.forEach((particle, i) => {
                positions[i * 3] = particle.position.x;
                positions[i * 3 + 1] = particle.position.y;
                positions[i * 3 + 2] = particle.position.z;
            });
            cursorParticleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        }

        const cursorParticleSystem = new THREE.Points(cursorParticleGeometry, cursorParticleMaterial);
        cursorParticleSystem.position.set(0, 0, 0);
        scene.add(cursorParticleSystem);

        function animatePoints() {
            const positions = pointGeometry.attributes.position.array;
            let currentIndex = 0;
            electronShells.forEach((shell, shellIndex) => {
                const shellStartIndex = currentIndex;
                const shellEndIndex = currentIndex + shell.electrons;
                for (let i = shellStartIndex; i < shellEndIndex; i++) {
                    const idx = i * 3;
                    let x = positions[idx];
                    let y = positions[idx + 1];
                    let z = positions[idx + 2];
                    const currentRadius = Math.sqrt(x * x + y * y + z * z);
                    const radiusCorrection = (shell.radius - currentRadius) * 0.1;
                    const radiusVector = {
                        x: x / currentRadius * radiusCorrection,
                        y: y / currentRadius * radiusCorrection,
                        z: z / currentRadius * radiusCorrection
                    };
                    let repulsionX = 0, repulsionY = 0, repulsionZ = 0;
                    for (let j = shellStartIndex; j < shellEndIndex; j++) {
                        if (i !== j) {
                            const dx = x - positions[j * 3];
                            const dy = y - positions[j * 3 + 1];
                            const dz = z - positions[j * 3 + 2];
                            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            if (distance < avoidanceDistance) {
                                const repulsion = (avoidanceDistance - distance) * repulsionStrength;
                                repulsionX += dx / distance * repulsion;
                                repulsionY += dy / distance * repulsion;
                                repulsionZ += dz / distance * repulsion;
                            }
                        }
                    }
                    velocities[idx] += radiusVector.x + repulsionX;
                    velocities[idx + 1] += radiusVector.y + repulsionY;
                    velocities[idx + 2] += radiusVector.z + repulsionZ;
                    positions[idx] += velocities[idx];
                    positions[idx + 1] += velocities[idx + 1];
                    positions[idx + 2] += velocities[idx + 2];
                }
                currentIndex += shell.electrons;
            });
            pointGeometry.attributes.position.needsUpdate = true;
        }

        function updateLines() {
            if (isMobile) return;

            const positions = pointGeometry.attributes.position.array;
            const linePositions = [];
            for (let i = 0; i < positions.length / 3; i++) {
                for (let j = i + 1; j < positions.length / 3; j++) {
                    const dx = positions[i * 3] - positions[j * 3];
                    const dy = positions[i * 3 + 1] - positions[j * 3 + 1];
                    const dz = positions[i * 3 + 2] - positions[j * 3 + 2];
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (distance < connectionDistance) {
                        linePositions.push(
                            positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                            positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
                        );
                    }
                }
            }
            lineSegments.geometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            lineSegments.geometry.computeBoundingSphere();
        }

        let Flag_CameraAnimation = true;
        let Time_CameraAnimation_Start = null;
        let Position_Trun_Start = null;

        let Elapsed;
        let Radius, Theta, Phi;

        const POSITION_START = new THREE.Vector3(0, 1, 0).multiplyScalar(2000);
        const POSITION_END = new THREE.Vector3(-20, 20, 40);
        const DISTANCE_INNER = 30;

        const DURATION_ALL = 20 * 1000;
        const DURATION_INNER = DURATION_ALL * 0.6;
        const DURATION_END = DURATION_ALL * 0.3;
        const DURATION_ADJUST = DURATION_ALL - DURATION_INNER - DURATION_END;

        function Calculate_Bezier(x, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
            let t = 0.5;
            const epsilon = 0.0001;
            const maxIterations = 10;
            for (let i = 0; i < maxIterations; i++) {
                let u = 1 - t;
                let tt = t * t;
                let uu = u * u;
                let uuu = uu * u;
                let ttt = tt * t;
                let currentX = uuu * p0x + 3 * uu * t * p1x + 3 * u * tt * p2x + ttt * p3x;
                let dx = -3 * p0x * uu + 3 * p1x * (1 - 4 * t + 3 * tt) + 3 * p2x * (2 * t - 3 * tt) + 3 * p3x * tt;
                if (Math.abs(x - currentX) < epsilon) break;
                t = t - (currentX - x) / dx;
                t = Math.max(0, Math.min(1, t));
            }
            let u = 1 - t;
            let tt = t * t;
            let uu = u * u;
            let uuu = uu * u;
            let ttt = tt * t;
            return uuu * p0y + 3 * uu * t * p1y + 3 * u * tt * p2y + ttt * p3y;
        }

        function Calculate_Radius() {
            if (Elapsed < DURATION_INNER) {
                const progress = Elapsed / DURATION_INNER;
                const distanceFactor = Calculate_Bezier(progress, 0, 1, 0.4, 1, 0.6, 0, 1, 0);
                Radius = POSITION_START.length() * distanceFactor + DISTANCE_INNER * (1 - distanceFactor);
            } else if (Elapsed < DURATION_ALL) {
                const progress = (Elapsed - DURATION_INNER) / DURATION_END;
                const distanceFactor = Calculate_Bezier(progress, 0, 0, 0.9, 0.1, 0.7, 0.7, 1, 1);
                const startDistance = DISTANCE_INNER;
                const endDistance = POSITION_END.length();
                Radius = startDistance * (1 - distanceFactor) + endDistance * distanceFactor;
            }
        }

        function Calculate_Theta() {
            if (Elapsed < DURATION_INNER) {
                const progress = Elapsed / DURATION_INNER;
                Theta = Math.PI * 0.5 - Math.PI * (90 / 180) * Calculate_Bezier(progress, 0, 0, 0.4, 0, 0.4, 0, 1, 1);
            } else if (Elapsed > DURATION_INNER + DURATION_END && Elapsed < DURATION_ALL) {
                const progress = (Elapsed - DURATION_INNER - DURATION_END) / DURATION_ADJUST;
                Theta = Math.PI * (10 / 180) * Calculate_Bezier(progress, 0, 0, 0.4, 0, 0.3, 1, 1, 1);
            }
        }

        function Calculate_Phi() {
            if (Elapsed < DURATION_INNER) {
                const progress = Elapsed / DURATION_INNER;
                Phi = Math.PI * 4 * Calculate_Bezier(progress, 0, 0, 0.4, 0, 0.4, 0, 1, 1);
            } else if (Elapsed < DURATION_INNER + DURATION_END) {
                const progress = (Elapsed - DURATION_INNER) / DURATION_END;
                Phi = Math.PI * 2 * Calculate_Bezier(progress, 0, 0, 0, 0.2, 0.8, 0.1, 1, 1);
            } else if (Elapsed < DURATION_ALL) {
                const progress = (Elapsed - DURATION_INNER - DURATION_END) / DURATION_ADJUST;
                Phi = Math.PI * (120 / 180) * Calculate_Bezier(progress, 0, 0, 0, 0.4, 0.4, 0.9, 1, 1);
            }
        }

        let lastTime = performance.now();
        let countDistance = Math.PI;
        let countTheata = Math.PI;
        let time = 0.0;
        let frameCount = 0;

        const messages = ["Hi!", "Welcome to FUM Website!", "How are you?", "May I help you?", "Space is vast…", "Let's explore!", "It's fun to learn something new, …isn't it?", "I wonder if SpaceX will take me to space…", "What is that flying around me…?", "I'm FUM. Nice to meet you.", "…", "He may well be bored…"];
        const MESSAGE_DISTANCE_THRESHOLD = 35;
        let messageVisible = false;
        let messageCooldown = false;

        function updateSpeechBubble() {
            if (!liquidSphere || !vue) return;

            const distance = camera.position.distanceTo(liquidSphere.position);

            if (distance < MESSAGE_DISTANCE_THRESHOLD && !messageVisible && !messageCooldown) {
                messageVisible = true;
                messageCooldown = true;
                vue.ShowMessage = true;

                const randomIndex = Math.floor(Math.random() * messages.length);
                vue.CurrentMessage = messages[randomIndex];

                setTimeout(() => {
                    messageVisible = false;
                    vue.ShowMessage = false;
                    setTimeout(() => {
                        messageCooldown = false;
                    }, 3000);
                }, 4000);
            }

            if (vue.ShowMessage) {
                const screenPosition = liquidSphere.position.clone().project(camera);
                const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                const MAX_DISTANCE = MESSAGE_DISTANCE_THRESHOLD;
                const MIN_DISTANCE = 15;
                const currentDistance = camera.position.distanceTo(liquidSphere.position);
                let proximityFactor = (MAX_DISTANCE - currentDistance) / (MAX_DISTANCE - MIN_DISTANCE);
                proximityFactor = Math.max(0, Math.min(1, proximityFactor));
                const yOffsetFar = 0.45;
                const yOffsetClose = 0.38;
                const dynamicOffsetY = yOffsetFar + (yOffsetClose - yOffsetFar) * proximityFactor;
                const y = (-screenPosition.y * 0.5 + dynamicOffsetY) * window.innerHeight;

                vue.MessageStyle = {
                    top: `${y}px`,
                    left: `${x}px`
                };
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            time += deltaTime;

            liquidShaderMaterial.uniforms.time.value = time;
            liquidShaderMaterial.uniforms.viewPos.value.copy(camera.position);
            liquidShaderMaterial.uniforms.cameraDistance.value = camera.position.length();

            if (Flag_CameraAnimation) {
                if (Time_CameraAnimation_Start === null) {
                    Time_CameraAnimation_Start = currentTime;
                    Position_Trun_Start = camera.position.clone();
                }
                Elapsed = currentTime - Time_CameraAnimation_Start;
                if (Elapsed < DURATION_ALL) {
                    Calculate_Radius();
                    Calculate_Theta();
                    Calculate_Phi();
                    const x = Radius * Math.cos(Theta) * Math.cos(Phi);
                    const y = Radius * Math.sin(Theta);
                    const z = Radius * Math.cos(Theta) * Math.sin(Phi);
                    camera.position.set(x, y, z);
                    camera.lookAt(0, 0, 0);
                }
                if (Elapsed > DURATION_ALL) {
                    Flag_CameraAnimation = false;
                    controls.maxDistance = 1200;
                    controls.enabled = true;

                    // カメラアニメーションが終わったら花火を有効化
                    fireworksEnabled = true;
                    setTimeout(() => launchFirework(), 500); // 最初の花火
                    setInterval(launchFirework, 4000); // 定期的な花火
                }
            } else {
                countDistance += Math.PI * 0.01 * deltaTime;
                const currentDistance = camera.position.length();
                let newDistance = currentDistance + Math.sin(countDistance) * 2 * deltaTime;
                if (newDistance < 18) {
                    newDistance = 18;
                    countDistance += Math.PI * deltaTime;
                }
                const currentPhi = Math.atan2(camera.position.z, camera.position.x);
                const newPhi = currentPhi + Math.PI * 0.05 * deltaTime;
                countTheata += Math.PI * 0.2 * deltaTime;
                let currentTheta = Math.asin(camera.position.y / newDistance);
                if (currentTheta <= -Math.PI * 0.49) {
                    currentTheta = -Math.PI * 0.49;
                }
                if (currentTheta >= Math.PI * 0.49) {
                    currentTheta = Math.PI * 0.49;
                }
                const newTheta = currentTheta + Math.sin(countTheata) * Math.PI * 2.5 / 180 * deltaTime;
                const x = newDistance * Math.cos(newTheta) * Math.cos(newPhi);
                const y = newDistance * Math.sin(newTheta);
                const z = newDistance * Math.cos(newTheta) * Math.sin(newPhi);
                camera.position.set(x, y, z);
                camera.lookAt(0, 0, 0);
            }

            animatePoints();
            frameCount++;
            // animatePointsは2フレームに1回実行
            if (frameCount % 2 === 0) {
                animatePoints();
            }

            if (!isMobile) {
                // updateLinesは計算量が非常に大きいため、15フレームに1回に減らす
                // もしくは、線を引く必要がなければこのブロックごとコメントアウトすると最も効果的です
                if (frameCount % 30 === 0) {
                    updateLines();
                }
            }
            updateCursorParticles();

            // 花火の更新処理
            if (fireworksEnabled) {
                for (let i = fireworks.length - 1; i >= 0; i--) {
                    if (fireworks[i].update(deltaTime)) {
                        fireworks.splice(i, 1);
                    }
                }
            }

            controls.update();
            composer.render();
            if (!isMobile) {
                updateGlitch();
            }
            // 口パクアニメーション
            if (vue && vue.ShowMessage && textMeshMouthClosed && textMeshMouthOpen) {
                // 0.25秒ごとに切り替え
                const isMouthOpen = Math.floor(time * 2) % 2 === 0;
                textMeshMouthClosed.visible = !isMouthOpen;
                textMeshMouthOpen.visible = isMouthOpen;
            } else if (textMeshMouthClosed && textMeshMouthOpen) {
                // 吹き出しが非表示のときは口を閉じる
                textMeshMouthClosed.visible = true;
                textMeshMouthOpen.visible = false;
            }
            updateSpeechBubble();
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.at(20, intersectionPoint);
            if (Math.random() < 0.5) {
                createCursorParticle(intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);
            }
        }

        window.addEventListener('mousemove', onMouseMove);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('click', () => {
            launchFirework();
        });
        window.addEventListener('touchend', () => {
            launchFirework();
        });

        animate();

        const colorDistribution = [
            {
                type: "blue-white", prob: 0.45, colors: [
                    { r: 0.53, g: 0.67, b: 1.0 },
                    { r: 0.67, g: 0.73, b: 1.0 },
                    { r: 0.93, g: 0.93, b: 1.0 }
                ]
            },
            {
                type: "yellow", prob: 0.325, colors: [
                    { r: 1.0, g: 1.0, b: 0.8 },
                    { r: 1.0, g: 1.0, b: 0.6 }
                ]
            },
            {
                type: "orange-red", prob: 0.225, colors: [
                    { r: 1.0, g: 0.67, b: 0.4 },
                    { r: 1.0, g: 0.4, b: 0.4 }
                ]
            }
        ];

        const randomColor = () => {
            const rand = Math.random();
            let cumulativeProb = 0;
            for (const category of colorDistribution) {
                cumulativeProb += category.prob;
                if (rand <= cumulativeProb) {
                    const colorChoice = category.colors[Math.floor(Math.random() * category.colors.length)];
                    return new THREE.Color(colorChoice.r, colorChoice.g, colorChoice.b);
                }
            }
            return new THREE.Color(1, 1, 1);
        };

        function createUniverseDetail() {
            // パフォーマンス向上のためパーティクル数をさらに削減
            const starCount = isMobile ? 2000 : 4000;
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const r = 2000 + Math.random() * 2000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                starPositions[i * 3] = r * Math.sin(theta) * Math.cos(phi);
                starPositions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                starPositions[i * 3 + 2] = r * Math.cos(theta);
                const color = randomColor();
                starColors[i * 3] = color.r;
                starColors[i * 3 + 1] = color.g;
                starColors[i * 3 + 2] = color.b;
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            const starMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: isMobile ? 20 : 10,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                fog: false
            });
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);

            const galaxyStars = isMobile ? 500 : 1000;
            const galaxyPositions = new Float32Array(galaxyStars * 3);
            const galaxyColors = new Float32Array(galaxyStars * 3);
            const spiralArms = 4;
            const spiralSpread = 10;
            const minGalaxyRadius = 40;
            const maxGalaxyRadius = 200;

            const armWeights = [1, 1.5, 1, 1.5];
            const totalWeight = armWeights.reduce((sum, weight) => sum + weight, 0);
            const armAngles = [];
            let cumulativeWeight = 0;
            for (let i = 0; i < spiralArms; i++) {
                armAngles.push((cumulativeWeight / totalWeight) * (2 * Math.PI));
                cumulativeWeight += armWeights[i];
            }

            for (let i = 0; i < galaxyStars; i++) {
                let r = minGalaxyRadius + (maxGalaxyRadius - minGalaxyRadius) * Math.sqrt(Math.random());
                let armIndex = i % spiralArms;
                let baseArmAngle = armAngles[armIndex];
                let twist = r * 0.04;
                let randomScatter = (Math.random() - 0.5) * 0.4;
                let angle = baseArmAngle + twist + randomScatter;

                const x = r * Math.cos(angle) + (Math.random() - 0.5) * spiralSpread;
                const y = (Math.random() - 0.5) * (spiralSpread * 0.3);
                const z = r * Math.sin(angle) + (Math.random() - 0.5) * spiralSpread;
                galaxyPositions[i * 3] = x;
                galaxyPositions[i * 3 + 1] = y;
                galaxyPositions[i * 3 + 2] = z;

                let t = r / maxGalaxyRadius;
                let color = new THREE.Color();
                if (t < 0.5) {
                    color.set(0xfff4e5);
                } else {
                    color.set(0xffeedd);
                }
                galaxyColors[i * 3] = color.r;
                galaxyColors[i * 3 + 1] = color.g;
                galaxyColors[i * 3 + 2] = color.b;
            }

            const galaxyGeometry = new THREE.BufferGeometry();
            galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(galaxyPositions, 3));
            galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(galaxyColors, 3));
            const galaxyFieldMaterial = new THREE.PointsMaterial({
                map: particleTexture,
                vertexColors: true,
                size: isMobile ? 0.5 : 0.25,
                transparent: false,         // 透明度を無効化
                depthWrite: true,           // 深度情報を書き込む
                fog: false
            });
            const galaxyField = new THREE.Points(galaxyGeometry, galaxyFieldMaterial);
            scene.add(galaxyField);

            const nebulaCount = isMobile ? 100 : 500;
            const nebulaPositions = new Float32Array(nebulaCount * 3);
            const nebulaColors = new Float32Array(nebulaCount * 3);
            const nebulaMinRadius = 100;
            const nebulaMaxRadius = 300;
            for (let i = 0; i < nebulaCount; i++) {
                const u = Math.random();
                const r = Math.cbrt(u * (Math.pow(nebulaMaxRadius, 3) - Math.pow(nebulaMinRadius, 3)) + Math.pow(nebulaMinRadius, 3));

                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                const x = r * Math.sin(theta) * Math.cos(phi);
                const y = r * 0.3 * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(theta);
                nebulaPositions[i * 3] = x;
                nebulaPositions[i * 3 + 1] = y;
                nebulaPositions[i * 3 + 2] = z;

                const color = new THREE.Color(0x334455).lerp(new THREE.Color(0x88aaff), Math.random() * 0.3);
                nebulaColors[i * 3] = color.r;
                nebulaColors[i * 3 + 1] = color.g;
                nebulaColors[i * 3 + 2] = color.b;
            }
            const nebulaGeometry = new THREE.BufferGeometry();
            nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
            nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
            const nebulaMaterial = new THREE.PointsMaterial({
                map: particleTexture,
                vertexColors: true,
                size: 1,
                transparent: true,
                opacity: 0.75,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                fog: false
            });
            const nebulaField = new THREE.Points(nebulaGeometry, nebulaMaterial);
            scene.add(nebulaField);

            // パーティクル用のテクスチャ
            function createSparkleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const context = canvas.getContext('2d');
                const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 32, 32);
                return new THREE.CanvasTexture(canvas);
            }
            const sparkleTexture = createSparkleTexture();
            const sparkleCount = isMobile ? 30 : 150;

            const sparklePositions = new Float32Array(sparkleCount * 3);
            const sparkleColors = new Float32Array(sparkleCount * 3);

            for (let i = 0; i < sparkleCount; i++) {
                const r = 2000 + Math.random() * 1000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                const i3 = i * 3;

                sparklePositions[i3 + 0] = r * Math.sin(theta) * Math.cos(phi);
                sparklePositions[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                sparklePositions[i3 + 2] = r * Math.cos(theta);

                const color = randomColor();
                sparkleColors[i3 + 0] = color.r;
                sparkleColors[i3 + 1] = color.g;
                sparkleColors[i3 + 2] = color.b;
            }

            const sparkleGeometry = new THREE.BufferGeometry();
            sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));
            sparkleGeometry.setAttribute('color', new THREE.BufferAttribute(sparkleColors, 3));

            // 設定を見直し、確実に描画されるように調整します。
            const sparkleMaterial = new THREE.PointsMaterial({
                map: sparkleTexture,
                size: 60, // サイズを大きくして視認性を向上させます
                vertexColors: true,
                blending: THREE.AdditiveBlending, // 加算合成で輝きを表現
                transparent: false,
                depthWrite: false,
                fog: false
            });

            const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
            scene.add(sparkles);

            const sparkleTexture_wide = createSparkleTexture();
            const sparkleCount_wide = isMobile ? 20 : 100;
            for (let i = 0; i < sparkleCount_wide; i++) {
                const r = 2000 + Math.random() * 1000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                const sprite = new THREE.Sprite(
                    new THREE.SpriteMaterial({
                        map: sparkleTexture_wide,
                        color: randomColor(),
                        transparent: true,
                        opacity: 1,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        fog: false
                    })
                );
                sprite.position.set(
                    r * Math.sin(theta) * Math.cos(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(theta)
                );
                sprite.scale.set(50 + Math.random() * 50, 30 + Math.random() * 50, 1);
                scene.add(sprite);
            }

            const clusterCount = isMobile ? 2 : 4;
            for (let c = 0; c < clusterCount; c++) {
                const clusterRadius = 2000;
                const clusterTheta = Math.acos(2 * Math.random() - 1);
                const clusterPhi = Math.random() * 2 * Math.PI;
                const clusterCenter = new THREE.Vector3(
                    clusterRadius * Math.sin(clusterTheta) * Math.cos(clusterPhi),
                    clusterRadius * Math.sin(clusterTheta) * Math.sin(clusterPhi),
                    clusterRadius * Math.cos(clusterTheta)
                );
                const galaxyInCluster = 3 + Math.floor(Math.random() * 5);
                for (let g = 0; g < galaxyInCluster; g++) {
                    const particleCount = 25 + Math.floor(Math.random() * 25);
                    const clusterPositions = new Float32Array(particleCount * 3);
                    const clusterColors = new Float32Array(particleCount * 3);
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100
                    );

                    const centerColor = new THREE.Color(0xffaa55);
                    const outerColor = new THREE.Color(0x55aaff);
                    const galaxyRadius = 50;

                    for (let i = 0; i < particleCount; i++) {
                        const r = Math.random() * galaxyRadius;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;

                        clusterPositions[i * 3] = clusterCenter.x + offset.x + r * Math.sin(theta) * Math.cos(phi);
                        clusterPositions[i * 3 + 1] = clusterCenter.y + offset.y + r * Math.sin(theta) * Math.sin(phi);
                        clusterPositions[i * 3 + 2] = clusterCenter.z + offset.z + r * Math.cos(theta);

                        const color = centerColor.clone().lerp(outerColor, r / galaxyRadius);

                        clusterColors[i * 3] = color.r;
                        clusterColors[i * 3 + 1] = color.g;
                        clusterColors[i * 3 + 2] = color.b;
                    }
                    const clusterGeometry = new THREE.BufferGeometry();
                    clusterGeometry.setAttribute('position', new THREE.BufferAttribute(clusterPositions, 3));
                    clusterGeometry.setAttribute('color', new THREE.BufferAttribute(clusterColors, 3));
                    const clusterMaterial = new THREE.PointsMaterial({
                        vertexColors: true,
                        size: 0.1 + Math.random() * 0.3,
                        sizeAttenuation: true,
                        transparent: true,
                        opacity: 0.5,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        fog: false
                    });
                    const clusterField = new THREE.Points(clusterGeometry, clusterMaterial);
                    scene.add(clusterField);
                }
            }

            const distantGalaxyCount = isMobile ? 50 : 300;
            for (let g = 0; g < distantGalaxyCount; g++) {
                const particleCount = 50 + Math.floor(Math.random() * 50);
                const galaxyRadius = 2000 + Math.random() * 1000;
                const galaxyTheta = Math.acos(2 * Math.random() - 1);
                const galaxyPhi = Math.random() * 2 * Math.PI;
                const distantPositions = new Float32Array(particleCount * 3);
                const distantColors = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const r = Math.random() * 30;
                    const theta = Math.acos(2 * Math.random() - 1);
                    const phi = Math.random() * 2 * Math.PI;
                    distantPositions[i * 3] = galaxyRadius * Math.sin(galaxyTheta) * Math.cos(galaxyPhi) + r * Math.sin(theta) * Math.cos(phi);
                    distantPositions[i * 3 + 1] = galaxyRadius * Math.sin(galaxyTheta) * Math.sin(galaxyPhi) + r * Math.sin(theta) * Math.sin(phi);
                    distantPositions[i * 3 + 2] = galaxyRadius * Math.cos(galaxyTheta) + r * Math.cos(theta);
                    const color = randomColor();
                    distantColors[i * 3] = color.r;
                    distantColors[i * 3 + 1] = color.g;
                    distantColors[i * 3 + 2] = color.b;
                }
                const distantGeometry = new THREE.BufferGeometry();
                distantGeometry.setAttribute('position', new THREE.BufferAttribute(distantPositions, 3));
                distantGeometry.setAttribute('color', new THREE.BufferAttribute(distantColors, 3));
                const distantMaterial = new THREE.PointsMaterial({
                    vertexColors: true,
                    size: 2 + Math.random() * 3,
                    transparent: true,
                    opacity: 0.25,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    fog: false
                });
                const distantField = new THREE.Points(distantGeometry, distantMaterial);
                scene.add(distantField);
            }

            const blackHoleCount = 10;
            const blackHoleMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                fog: false
            });
            for (let i = 0; i < blackHoleCount; i++) {
                const radius = 25 + Math.random() * 25;
                const blackHoleGeometry = new THREE.SphereGeometry(radius, 8, 8);
                const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
                const r = 1500 + Math.random() * 1000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                blackHole.position.set(
                    r * Math.sin(theta) * Math.cos(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(theta)
                );
                blackHole.castShadow = false;
                blackHole.receiveShadow = false;
                scene.add(blackHole);
            }
        }

        // 図形花火用の頂点データ
        function getShapePoints(shape) {
            const points = [];
            const scale = 15; // 図形の基準サイズ
            const numPoints = 150; // 図形を構成するポイント数

            switch (shape) {
                case 'heart':
                    for (let i = 0; i < numPoints; i++) {
                        const t = (i / numPoints) * 2 * Math.PI;
                        const x = scale * 1.0 * Math.pow(Math.sin(t), 3);
                        const y = scale * (0.8 * Math.cos(t) - 0.3 * Math.cos(2 * t) - 0.1 * Math.cos(3 * t) - 0.05 * Math.cos(4 * t));
                        points.push(new THREE.Vector3(x, y + 2, 0));
                    }
                    break;
                case 'star':
                    const outerRadius = scale;
                    const innerRadius = scale * 0.5;
                    for (let i = 0; i < numPoints; i++) {
                        const angle = (i / numPoints) * 5 * Math.PI;
                        const r = i % 2 === 0 ? outerRadius : innerRadius;
                        const finalRadius = innerRadius + (outerRadius - innerRadius) * Math.abs(Math.sin(angle * 2.5));
                        points.push(new THREE.Vector3(finalRadius * Math.cos(angle), finalRadius * Math.sin(angle), 0));
                    }
                    break;
                case 'saturn':
                    const bodyPoints = Math.floor(numPoints * 0.4);
                    const ringPoints = numPoints - bodyPoints;
                    const bodyRadius = scale * 0.7;
                    const ringInnerRadius = scale * 1.0;
                    const ringOuterRadius = scale * 1.6;
                    const tilt = 0.2; // 環の傾き（ラジアン）

                    // 本体の生成 (フィボナッチ格子を使って球状に配置)
                    const phi = Math.PI * (3. - Math.sqrt(5.)); // 黄金角
                    for (let i = 0; i < bodyPoints; i++) {
                        const y = 0.25 - (i / (bodyPoints - 0.25)) * 2; // y座標を-1から1に
                        const radius = Math.sqrt(0.25 - y * y);
                        const theta = phi * i;
                        const x = Math.cos(theta) * radius;
                        const z = Math.sin(theta) * radius;
                        points.push(new THREE.Vector3(x, y, z).multiplyScalar(bodyRadius));
                    }

                    // 環の生成
                    for (let i = 0; i < ringPoints; i++) {
                        // 円環内にランダムな点を生成
                        const angle = Math.random() * Math.PI * 2;
                        // Math.sqrt(Math.random()) を使い、中心部に点が偏らないようにする
                        const radius = Math.sqrt(Math.random()) * (ringOuterRadius - ringInnerRadius) + ringInnerRadius;

                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;

                        // 環を傾けるための回転計算
                        const rotatedY = z * Math.sin(tilt);
                        const rotatedZ = z * Math.cos(tilt);

                        points.push(new THREE.Vector3(x, rotatedY, rotatedZ));
                    }
                    break;
            }
            return points;
        }

        class Firework {
            constructor({ x, y, z, type, color, subFirework = false }) {
                this.type = type;
                this.color = color || new THREE.Color().setHSL(Math.random(), 1, 0.7);
                this.subFirework = subFirework;

                const material = new THREE.PointsMaterial({
                    size: subFirework ? 0.2 : 1,
                    color: 0xffeeb3,
                    map: particleTexture,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false,
                    fog: false
                });

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0, 0, 0]), 3));
                this.rocket = new THREE.Points(geometry, material);
                this.rocket.position.set(x, y, z);

                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    subFirework ? Math.random() * 5 + 10 : Math.random() * 5 + 20,
                    (Math.random() - 0.5) * 4
                );
                if (type === 'nishaku-dama' && !subFirework) {
                    this.velocity.y *= 1.5; // より高く打ち上げる
                }
                this.life = 0;
                this.exploded = false;
                scene.add(this.rocket);
            }

            explode() {
                this.exploded = true;
                scene.remove(this.rocket);

                // 図形花火の頂点データを取得
                let shapePoints = null;
                if (this.type.startsWith('shape-')) {
                    const shapeName = this.type.substring(6);
                    shapePoints = getShapePoints(shapeName);
                }

                // 花火の種類に応じて親玉のパーティクル数を決定
                let particleCount;
                if (shapePoints) {
                    particleCount = shapePoints.length;
                } else {
                    switch (this.type) {
                        case 'nishaku-dama':
                            particleCount = isMobile ? 150 : 350; // 削減
                            break;
                        case 'willow':
                        case 'crown':
                            particleCount = isMobile ? 100 : 200; // 削減
                            break;
                        case 'bun-pou': // 分砲の親玉は光らず、子玉のみで表現
                            particleCount = 0;
                            break;
                        default: // peony, chrysanthemumなど
                            particleCount = isMobile ? 60 : 120; // 削減
                    }
                }

                // 分砲や千輪の子玉を生成
                if (this.type === 'thousand-wheels' || this.type === 'bun-pou') {
                    const isBunpou = this.type === 'bun-pou';
                    const subCount = isMobile ? (isBunpou ? 8 : 4) : (isBunpou ? 20 : 6); // 削減
                    const launchDelay = isBunpou ? 0 : 200; // 千輪は親玉から少し遅れて開く

                    for (let i = 0; i < subCount; i++) {
                        setTimeout(() => {
                            if (fireworks.length >= MAX_FIREWORKS) return;

                            // 分砲は放射状に、千輪はよりランダムに広がる
                            const subVelocity = isBunpou
                                ? new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)).normalize().multiplyScalar(Math.random() * 10 + 15)
                                : new THREE.Vector3((Math.random() - 0.5) * 8, Math.random() * 8 + 4, (Math.random() - 0.5) * 8);

                            const fw = new Firework({
                                x: this.rocket.position.x,
                                y: this.rocket.position.y,
                                z: this.rocket.position.z,
                                type: ['peony', 'chrysanthemum'][Math.floor(Math.random() * 2)],
                                color: new THREE.Color().setHSL(Math.random(), 1, 0.7),
                                subFirework: true
                            });

                            fw.velocity.copy(subVelocity);
                            // 子玉が飛んでから開くまでの時間
                            fw.life = isBunpou ? 0.3 + Math.random() * 0.3 : 0.4;
                            fireworks.push(fw);
                        }, launchDelay + (isBunpou ? i * 20 : Math.random() * 200)); // 分砲は等間隔、千輪はランダムに射出
                    }
                }

                // 親玉のパーティクルを生成
                if (particleCount > 0) {
                    const positions = new Float32Array(particleCount * 3);
                    const colors = new Float32Array(particleCount * 3);
                    const velocities = [];
                    const lifetimes = new Float32Array(particleCount);

                    const geometry = new THREE.BufferGeometry();
                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            pointTexture: { value: particleTexture },
                            sizeScale: { value: 0.5 }
                        },
                        vertexShader: `
                            attribute float aLifetime;
                            attribute float aAge;
                            varying vec3 vColor;
                            varying float vAgeRatio;
                            uniform float sizeScale;

                            void main() {
                                vColor = color;
                                vAgeRatio = aAge / aLifetime;
                                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                                gl_PointSize = (1.0 - vAgeRatio) * (vAgeRatio < 0.5 ? 10.0 : 20.0) * sizeScale;
                                gl_Position = projectionMatrix * mvPosition;
                            }
                        `,
                        fragmentShader: `
                            uniform sampler2D pointTexture;
                            varying vec3 vColor;
                            varying float vAgeRatio;

                            void main() {
                                float alpha = (1.0 - pow(vAgeRatio, 2.0));
                                gl_FragColor = texture2D(pointTexture, gl_PointCoord);
                                gl_FragColor.rgb *= vColor;
                                gl_FragColor.a *= alpha;
                            }
                        `,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthWrite: false,
                        fog: false,
                        vertexColors: true
                    });

                    this.particles = new THREE.Points(geometry, material);
                    this.particles.position.copy(this.rocket.position);
                    scene.add(this.particles);

                    for (let i = 0; i < particleCount; i++) {
                        const vec = new THREE.Vector3();
                        if (shapePoints) {
                            vec.copy(shapePoints[i % shapePoints.length]).multiplyScalar(0.5 + Math.random() * 0.3);
                        } else {
                            vec.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                            let speed = Math.random() * 8 + 4;
                            if (this.type === 'crown' || this.type === 'willow') speed *= 0.7;
                            if (this.type === 'nishaku-dama') speed *= 1.3; // 二尺玉はより大きく広がる
                            vec.multiplyScalar(speed);
                        }

                        velocities.push(vec);
                        lifetimes[i] = Math.random() * 1.5 + 2.0; // 全体的に寿命を少し延ばす

                        let baseColor = this.color;
                        if (this.type === 'chrysanthemum') lifetimes[i] *= 1.5;
                        if (this.type === 'willow') {
                            baseColor = new THREE.Color(0xffd700);
                            lifetimes[i] *= 2.0;
                        }
                        if (this.type === 'nishaku-dama') {
                            lifetimes[i] *= 1.8; // 二尺玉はさらに長く輝く
                        }

                        const finalColor = baseColor.clone().lerp(new THREE.Color(0xffffff), 0.5);
                        finalColor.toArray(colors, i * 3);
                    }

                    this.particles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    this.particles.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    this.particleVelocities = velocities;
                    this.particleLifetimes = lifetimes;
                    this.particleAges = new Float32Array(particleCount).fill(0);
                    this.particles.geometry.setAttribute('aLifetime', new THREE.BufferAttribute(lifetimes, 1));
                    this.particles.geometry.setAttribute('aAge', new THREE.BufferAttribute(this.particleAges, 1));
                }

                // 閃光(フラッシュ)
                const isNishaku = this.type === 'nishaku-dama';
                const flash = new THREE.PointLight(
                    this.color,
                    isNishaku ? 5 : 2, // 二尺玉はより明るい
                    500, // 二尺玉はより広範囲
                    2
                );
                flash.position.copy(this.rocket.position);
                scene.add(flash);
                setTimeout(() => scene.remove(flash), 300);
            }

            update(dt) {
                if (this.exploded) {
                    // 1. 親玉パーティクルが存在する場合の更新処理
                    if (this.particles) {
                        const positions = this.particles.geometry.attributes.position.array;
                        const colors = this.particles.geometry.attributes.color.array;
                        let aliveCount = 0;
                        for (let i = 0; i < this.particleAges.length; i++) {
                            if (this.particleAges[i] < this.particleLifetimes[i]) {
                                this.particleAges[i] += dt;
                                this.particleVelocities[i].add(gravity);
                                if (this.type === 'willow' || this.type === 'crown') this.particleVelocities[i].y -= 0.03;

                                positions[i * 3] += this.particleVelocities[i].x * dt;
                                positions[i * 3 + 1] += this.particleVelocities[i].y * dt;
                                positions[i * 3 + 2] += this.particleVelocities[i].z * dt;

                                const lifeRatio = this.particleAges[i] / this.particleLifetimes[i];
                                if (this.type === 'chrysanthemum') {
                                    const c = new THREE.Color(this.color);
                                    c.lerp(new THREE.Color(0xffaa33), lifeRatio);
                                    c.toArray(colors, i * 3);
                                }
                                aliveCount++;
                            }
                        }
                        this.particles.geometry.attributes.position.needsUpdate = true;
                        this.particles.geometry.attributes.color.needsUpdate = true;
                        this.particles.geometry.attributes.aAge.needsUpdate = true;

                        if (aliveCount === 0) {
                            scene.remove(this.particles);
                            this.particles.geometry.dispose();
                            this.particles.material.dispose();
                            this.particles = null; // 役割を終えたので null にする
                        }
                    }
                    // 2. 親玉パーティクルが存在しない（または消滅した）場合の削除判定
                    else {
                        // 子玉を生成する花火は、生成が終わるまで待機
                        if (this.type === 'bun-pou' || this.type === 'thousand-wheels') {
                            if (!this.explodedTime) this.explodedTime = 0;
                            this.explodedTime += dt;
                            // 子玉生成のタイムアウト(最大500ms)後、安全マージンをもって削除
                            if (this.explodedTime > 1.0) {
                                return true; // 自身を削除
                            }
                        } else {
                            // 親玉のみの花火は、パーティクルが消えたら即座に削除
                            return true;
                        }
                    }
                } else {
                    this.life += dt;
                    this.rocket.position.add(this.velocity.clone().multiplyScalar(dt));
                    this.velocity.add(gravity);
                    if (this.velocity.y < 0) {
                        this.explode();
                    }
                }
                return false;
            }
        }

        function launchFirework() {
            if (!fireworksEnabled) return;
            if (fireworks.length >= MAX_FIREWORKS) return;

            const type = fireworkTypes[Math.floor(Math.random() * fireworkTypes.length)];
            const x = (Math.random() - 0.5) * 150;
            const y = 0;
            const z = (Math.random() - 0.5) * 150; // 少し奥に

            if (type === 'bouquet') {
                const bouquetCount = isMobile ? 2 : 3;
                for (let i = 0; i < bouquetCount; i++) {
                    setTimeout(() => {
                        if (fireworks.length >= MAX_FIREWORKS) return;
                        fireworks.push(new Firework({
                            x: x + (Math.random() - 0.5) * 50, y: y, z: z + (Math.random() - 0.5) * 50,
                            type: ['peony', 'chrysanthemum'][Math.floor(Math.random() * 2)]
                        }));
                    }, i * 200);
                }
            } else {
                fireworks.push(new Firework({ x, y, z, type }));
            }
        }

        createUniverseDetail();
    </script>
</body>

</html>