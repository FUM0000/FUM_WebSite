<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="author" content="F U M">
    <meta name="description" content="FUM_Website">
    <meta name="robots" content="index, follow">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-B89KY0993B"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-B89KY0993B');
    </script>
    <link rel="canonical" href="https://fum0000.github.io/FUM_WebSite/English/HTML/index.html">

    <link rel="icon" type="image/x-icon" href="../../Asset/Image/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../Asset/Image/Icon_1_2.jpg">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Zen+Kaku+Gothic+New:wght@400;500;700&display=swap" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="../../Asset/CSS/Common.css?v=1.0" rel="stylesheet" />

    <title>FUM_Website</title>
</head>

<body>

    <!-- ローディング画面 -->
    <div id="loading-overlay">
        <div class="intro-circle">
            <div class="inner-circle"></div>
            <div class="text-orbit">
                <span class="orbit-letter">F</span><span class="orbit-letter">U</span><span
                    class="orbit-letter">M</span><span class="orbit-letter"></span><span
                    class="orbit-letter"></span><span class="orbit-letter"></span><span
                    class="orbit-letter">F</span><span class="orbit-letter">U</span><span
                    class="orbit-letter">M</span><span class="orbit-letter"></span><span
                    class="orbit-letter"></span><span class="orbit-letter"></span>
            </div>
        </div>
        <div class="loading-text">
            <span>L</span><span>o</span><span>a</span><span>d</span><span>i</span><span>n</span><span>g</span><span>.</span><span>.</span><span>.</span>
        </div>
        <div class="loading-progress-container">
            <div class="loading-progress-bar" id="loadingProgress"></div>
        </div>
    </div>

    <!-- メインコンテンツ -->
    <canvas id="ElectronShell"></canvas>

    <v-app id="App">
        <template>
            <main-system-bar :drawer="Drawer" @change-drawer="ChangeDrawer">Home</main-system-bar>

            <v-main id="Main">
                <transition name="Fade_Page">
                    <v-container v-show="Ready_Page" fluid fill-height class="pa-5" style="align-content: flex-start;">
                        <!-- テキストフロー -->
                        <v-container id="TextFlow">
                            <span style="color: red"> &lt;NEWS&gt; </span>
                            <span style="color: rgb(200, 200, 200)">
                                New Year’s Day celebrates the beginning of a fresh
                                year, spent resting, being with family, and thinking about health, happiness, and plans
                                for the year ahead.
                            </span>
                        </v-container>
                    </v-container>
                </transition>
            </v-main>

            <!-- 吹き出し -->
            <div :class="['speech-bubble', { 'show': ShowMessage }]" :style="MessageStyle">
                {{ CurrentMessage }}
            </div>

            <main-navigation :drawer="Drawer" @change-drawer="ChangeDrawer"></main-navigation>
            <main-footer-simple></main-footer-simple>
        </template>
    </v-app>

    <style>
        body {
            overflow: hidden;
        }

        #ElectronShell {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #App {
            position: relative;
            z-index: 1;
            background-color: transparent !important;
            pointer-events: none;
        }

        #App a,
        #App button,
        #App input,
        #App select,
        #App textarea,
        #App .v-btn,
        #App .v-list-item,
        #App .v-icon {
            pointer-events: auto;
        }

        #TextFlow {
            width: calc(1920px * 0.75);
            white-space: nowrap;
            animation: Flow 30s linear infinite;
        }

        @keyframes Flow {
            0% {
                transform: translateX(100vw);
            }

            100% {
                transform: translateX(calc(-1920px * 0.75));
            }
        }

        .speech-bubble {
            position: absolute;
            background: rgba(30, 30, 30, 0.85);
            border: 1px solid #00ffcc;
            border-radius: 10px;
            padding: 10px 15px;
            color: #00ffcc;
            font-weight: 500;
            z-index: 5;
            pointer-events: none;
            transform: translate(-50%, -130%);
            white-space: nowrap;
            transition: opacity 0.3s ease-in-out, top 0.1s linear, left 0.1s linear;
            opacity: 0;
        }

        .speech-bubble.show {
            opacity: 1;
        }

        .speech-bubble::before {
            content: '';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 12px solid #00ffcc;
            z-index: -1;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid rgba(30, 30, 30, 0.85);
        }


        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #111111;
            z-index: 9999;
            opacity: 1;
            transition: opacity 2s ease-out;
            pointer-events: auto;
        }

        #loading-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .intro-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 2s ease-out;
        }

        .inner-circle {
            position: absolute;
            width: 198px;
            height: 198px;
            border-radius: 50%;
            background: #111111;
            opacity: 1;
            z-index: 1;
        }

        .text-orbit {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 225px;
            height: 225px;
            transform: translate(-50%, -50%);
            animation: orbit 5s linear infinite;
        }

        .orbit-letter {
            position: absolute;
            font-size: 36px;
            font-weight: 700;
            color: #fff;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .orbit-letter.positioned {
            opacity: 1;
        }

        @keyframes orbit {
            from {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            to {
                transform: translate(-50%, -50%) rotate(-360deg);
            }
        }

        .loading-text {
            position: fixed;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            font-weight: 500;
            color: #fff;
            display: flex;
            gap: 4px;
        }

        .loading-text span {
            opacity: 0;
            animation: loadingAnim 4s linear infinite;
        }

        .loading-text span:nth-child(1) {
            animation-delay: 0s;
        }

        .loading-text span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading-text span:nth-child(3) {
            animation-delay: 0.4s;
        }

        .loading-text span:nth-child(4) {
            animation-delay: 0.6s;
        }

        .loading-text span:nth-child(5) {
            animation-delay: 0.8s;
        }

        .loading-text span:nth-child(6) {
            animation-delay: 1.0s;
        }

        .loading-text span:nth-child(7) {
            animation-delay: 1.2s;
        }

        .loading-text span:nth-child(8) {
            animation-delay: 1.4s;
        }

        .loading-text span:nth-child(9) {
            animation-delay: 1.6s;
        }

        .loading-text span:nth-child(10) {
            animation-delay: 1.8s;
        }

        @keyframes loadingAnim {
            0% {
                opacity: 0;
            }

            20% {
                opacity: 1;
            }

            50% {
                opacity: 1;
            }

            70% {
                opacity: 0;
            }

            100% {
                opacity: 0;
            }
        }

        .loading-progress-container {
            position: fixed;
            bottom: 13%;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            max-width: 400px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 40px;
            overflow: hidden;
        }

        .loading-progress-bar {
            width: 0%;
            height: 100%;
            background-color: #00ffcc;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.js"></script>
    <script src="../../Asset/Javascript/Common.js?v=1.03"></script>
    <script src="../../Asset/Javascript/Index.js?v=1.0"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js" defer></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js" defer></script>

    <script>
        window.vue = new Vue({
            el: '#App',
            vuetify: new Vuetify(),
            mixins: [window.Mixins_Common, window.Mixins_Index],
            data: {
                ShowMessage: false,
                CurrentMessage: '',
                MessageStyle: { top: '0px', left: '0px' }
            },
        })
        window.addEventListener('load', () => {
            const overlay = document.getElementById('loading-overlay');
            const progressBar = document.getElementById('loadingProgress');

            const orbitContainer = document.querySelector('.text-orbit');
            if (orbitContainer) {
                const letters = orbitContainer.querySelectorAll('.orbit-letter');
                const letterCount = letters.length;
                const radius = 112.5;
                const angleStep = 360 / letterCount;

                letters.forEach((letter, index) => {
                    const angleDeg = index * angleStep - 90;
                    const angleRad = angleDeg * (Math.PI / 180);

                    const x = radius * Math.cos(angleRad);
                    const y = radius * Math.sin(angleRad);

                    letter.style.left = `calc(50% + ${x}px)`;
                    letter.style.top = `calc(50% + ${y}px)`;

                    letter.style.transform = `translate(-50%, -50%) rotate(${index * angleStep}deg)`;

                    setTimeout(() => {
                        letter.classList.add('positioned');
                    }, index * 50);
                });
            }

            if (overlay && progressBar) {
                let progress = 0;
                const duration = 4000;
                const interval = 50;

                const timer = setInterval(() => {
                    progress += (100 / (duration / interval));
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(timer);
                    }
                    progressBar.style.width = progress + '%';
                }, interval);

                setTimeout(() => {
                    overlay.classList.add('fade-out');
                    setTimeout(() => {
                        overlay.remove();
                    }, 2000);
                }, 4000);
            }
        });
    </script>

    <script type="module">

        // セットアップ
        const vue = window.vue;
        const isMobile = window.innerWidth <= 768;
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x020202, 0, 5000);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector("#ElectronShell"),
            antialias: true
        });
        renderer.setClearColor(0x010104, 1);
        renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.5;
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });


        // 素材
        const colorDistribution = [
            {
                type: "blue-white", prob: 0.45, colors: [
                    { r: 0.53, g: 0.67, b: 1.0 },
                    { r: 0.67, g: 0.73, b: 1.0 },
                    { r: 0.93, g: 0.93, b: 1.0 }
                ]
            },
            {
                type: "yellow", prob: 0.325, colors: [
                    { r: 1.0, g: 1.0, b: 0.8 },
                    { r: 1.0, g: 1.0, b: 0.6 }
                ]
            },
            {
                type: "orange-red", prob: 0.225, colors: [
                    { r: 1.0, g: 0.67, b: 0.4 },
                    { r: 1.0, g: 0.4, b: 0.4 }
                ]
            }
        ];
        function createProceduralCubeMap() {
            const size = 64;
            const images = [];
            for (let i = 0; i < 6; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
                gradient.addColorStop(0, 'rgba(8, 25, 45, 255)');
                gradient.addColorStop(1, 'rgba(1, 3, 8, 255)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                images.push(canvas);
            }
            const cubeTexture = new THREE.CubeTexture(images);
            cubeTexture.format = THREE.RGBAFormat;
            cubeTexture.needsUpdate = true;
            return cubeTexture;
        }
        const envMap = createProceduralCubeMap();
        function generateNoiseTexture(width = 256, height = 256) {
            const size = width * height;
            const data = new Uint8Array(size * 4);
            for (let i = 0; i < size; i++) {
                const value = Math.random() * 255;
                data[i * 4] = value;
                data[i * 4 + 1] = value;
                data[i * 4 + 2] = value;
                data[i * 4 + 3] = 255;
            }
            const texture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.needsUpdate = true;
            return texture;
        }
        const voidTexture = generateNoiseTexture();
        function createCircleTexture() {
            const size = 16;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size / 2;
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
            context.fillStyle = '#FFFFFF';
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createCircleTexture();
        function createStarNoiseTexture(size = 1024, density = 0.002) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, size, size);

            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;

            for (let i = 0; i < size * size; i++) {
                if (Math.random() < density) {
                    const brightness = 200 + Math.random() * 55;
                    data[i * 4] = brightness;
                    data[i * 4 + 1] = brightness;
                    data[i * 4 + 2] = brightness;
                    data[i * 4 + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 2);
            return texture;
        }

        // カメラコントロール
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 0.8;
        controls.enablePan = false;
        controls.maxPolarAngle = Math.PI - 0.1;
        controls.minPolarAngle = 0.1;
        camera.position.copy(new THREE.Vector3(0, 1, 0).multiplyScalar(10000));
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        function easeInOutSloMo(t) {
            return Math.pow(easeInOutCubic(t), 2);
        }

        // ヴォイド
        const voidBackground = new THREE.Mesh(
            new THREE.SphereGeometry(3000, 16, 16),
            new THREE.MeshBasicMaterial({
                map: voidTexture,
                side: THREE.BackSide,
                opacity: 0.2,
                transparent: true,
                color: 0x020206,
                fog: false
            })
        );
        scene.add(voidBackground);
        const starNoiseTexture = createStarNoiseTexture();
        const starVoid = new THREE.Mesh(
            new THREE.SphereGeometry(2990, 32, 32),
            new THREE.MeshBasicMaterial({
                map: starNoiseTexture,
                side: THREE.BackSide,
                transparent: true,
                opacity: 0.2,
                color: 0xffffff,
                fog: false,
                depthWrite: false
            })
        );

        scene.add(starVoid);

        // 星々
        function randomColor() {
            const rand = Math.random();
            let cumulativeProb = 0;
            for (const category of colorDistribution) {
                cumulativeProb += category.prob;
                if (rand <= cumulativeProb) {
                    const colorChoice = category.colors[Math.floor(Math.random() * category.colors.length)];
                    return new THREE.Color(colorChoice.r, colorChoice.g, colorChoice.b);
                }
            }
            return new THREE.Color(1, 1, 1);
        };
        function createUniverseDetail() {
            const starCount = isMobile ? 2000 : 4000;
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const r = 2000 + Math.random() * 2000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                starPositions[i * 3] = r * Math.sin(theta) * Math.cos(phi);
                starPositions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                starPositions[i * 3 + 2] = r * Math.cos(theta);
                const color = randomColor();
                starColors[i * 3] = color.r;
                starColors[i * 3 + 1] = color.g;
                starColors[i * 3 + 2] = color.b;
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            const starMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: isMobile ? 20 : 10,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                fog: false
            });
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);

            const galaxyStars = isMobile ? 500 : 1000;
            const galaxyPositions = new Float32Array(galaxyStars * 3);
            const galaxyColors = new Float32Array(galaxyStars * 3);
            const spiralArms = 4;
            const spiralSpread = 10;
            const minGalaxyRadius = 40;
            const maxGalaxyRadius = 200;

            const armWeights = [1, 1.5, 1, 1.5];
            const totalWeight = armWeights.reduce((sum, weight) => sum + weight, 0);
            const armAngles = [];
            let cumulativeWeight = 0;
            for (let i = 0; i < spiralArms; i++) {
                armAngles.push((cumulativeWeight / totalWeight) * (2 * Math.PI));
                cumulativeWeight += armWeights[i];
            }

            for (let i = 0; i < galaxyStars; i++) {
                let r = minGalaxyRadius + (maxGalaxyRadius - minGalaxyRadius) * Math.sqrt(Math.random());
                let armIndex = i % spiralArms;
                let baseArmAngle = armAngles[armIndex];
                let twist = r * 0.04;
                let randomScatter = (Math.random() - 0.5) * 0.4;
                let angle = baseArmAngle + twist + randomScatter;

                const x = r * Math.cos(angle) + (Math.random() - 0.5) * spiralSpread;
                const y = (Math.random() - 0.5) * (spiralSpread * 0.3);
                const z = r * Math.sin(angle) + (Math.random() - 0.5) * spiralSpread;
                galaxyPositions[i * 3] = x;
                galaxyPositions[i * 3 + 1] = y;
                galaxyPositions[i * 3 + 2] = z;

                let t = r / maxGalaxyRadius;
                let color = new THREE.Color();
                if (t < 0.5) {
                    color.set(0xfff4e5);
                } else {
                    color.set(0xffeedd);
                }
                galaxyColors[i * 3] = color.r;
                galaxyColors[i * 3 + 1] = color.g;
                galaxyColors[i * 3 + 2] = color.b;
            }

            const galaxyGeometry = new THREE.BufferGeometry();
            galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(galaxyPositions, 3));
            galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(galaxyColors, 3));
            const galaxyFieldMaterial = new THREE.PointsMaterial({
                map: particleTexture,
                vertexColors: true,
                size: isMobile ? 0.5 : 0.25,
                transparent: false,
                depthWrite: true,
                fog: false
            });
            const galaxyField = new THREE.Points(galaxyGeometry, galaxyFieldMaterial);
            scene.add(galaxyField);

            // 霧散らばる星屑
            const nebulaCount = isMobile ? 100 : 500;
            const nebulaPositions = new Float32Array(nebulaCount * 3);
            const nebulaColors = new Float32Array(nebulaCount * 3);
            const nebulaMinRadius = 60;
            const nebulaMaxRadius = 250;
            for (let i = 0; i < nebulaCount; i++) {
                const u = Math.random();
                const r = nebulaMinRadius + u * (nebulaMaxRadius - nebulaMinRadius);

                // xz平面での距離をrとして直接制御
                const phi = Math.random() * 2 * Math.PI;
                const x = r * Math.cos(phi);
                const z = r * Math.sin(phi);
                // y座標は圧縮（-r*0.1 から r*0.1 の範囲）
                const y = (Math.random() - 0.5) * r * 0.2;
                nebulaPositions[i * 3] = x;
                nebulaPositions[i * 3 + 1] = y;
                nebulaPositions[i * 3 + 2] = z;

                const color = new THREE.Color(0x334455).lerp(new THREE.Color(0x88aaff), Math.random() * 0.3);
                nebulaColors[i * 3] = color.r;
                nebulaColors[i * 3 + 1] = color.g;
                nebulaColors[i * 3 + 2] = color.b;
            }
            const nebulaGeometry = new THREE.BufferGeometry();
            nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
            nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
            const nebulaMaterial = new THREE.PointsMaterial({
                map: particleTexture,
                vertexColors: true,
                size: 1,
                transparent: true,
                opacity: 0.75,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                fog: false
            });
            const nebulaField = new THREE.Points(nebulaGeometry, nebulaMaterial);
            scene.add(nebulaField);

            // パーティクル用のテクスチャ
            function createSparkleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const context = canvas.getContext('2d');
                const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 32, 32);
                return new THREE.CanvasTexture(canvas);
            }
            const sparkleTexture = createSparkleTexture();
            const sparkleCount = isMobile ? 30 : 150;

            const sparklePositions = new Float32Array(sparkleCount * 3);
            const sparkleColors = new Float32Array(sparkleCount * 3);

            for (let i = 0; i < sparkleCount; i++) {
                const r = 2000 + Math.random() * 1000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                const i3 = i * 3;

                sparklePositions[i3 + 0] = r * Math.sin(theta) * Math.cos(phi);
                sparklePositions[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                sparklePositions[i3 + 2] = r * Math.cos(theta);

                const color = randomColor();
                sparkleColors[i3 + 0] = color.r;
                sparkleColors[i3 + 1] = color.g;
                sparkleColors[i3 + 2] = color.b;
            }

            const sparkleGeometry = new THREE.BufferGeometry();
            sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));
            sparkleGeometry.setAttribute('color', new THREE.BufferAttribute(sparkleColors, 3));

            const sparkleMaterial = new THREE.PointsMaterial({
                map: sparkleTexture,
                size: 60,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: false,
                depthWrite: false,
                fog: false
            });

            const sparkles = new THREE.Points(sparkleGeometry, sparkleMaterial);
            scene.add(sparkles);

            const sparkleTexture_wide = createSparkleTexture();
            const sparkleCount_wide = isMobile ? 20 : 100;
            for (let i = 0; i < sparkleCount_wide; i++) {
                const r = 2000 + Math.random() * 1000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                const sprite = new THREE.Sprite(
                    new THREE.SpriteMaterial({
                        map: sparkleTexture_wide,
                        color: randomColor(),
                        transparent: true,
                        opacity: 1,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        fog: false
                    })
                );
                sprite.position.set(
                    r * Math.sin(theta) * Math.cos(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(theta)
                );
                sprite.scale.set(50 + Math.random() * 50, 30 + Math.random() * 50, 1);
                scene.add(sprite);
            }

            const clusterCount = isMobile ? 2 : 4;
            for (let c = 0; c < clusterCount; c++) {
                const clusterRadius = 2000;
                const clusterTheta = Math.acos(2 * Math.random() - 1);
                const clusterPhi = Math.random() * 2 * Math.PI;
                const clusterCenter = new THREE.Vector3(
                    clusterRadius * Math.sin(clusterTheta) * Math.cos(clusterPhi),
                    clusterRadius * Math.sin(clusterTheta) * Math.sin(clusterPhi),
                    clusterRadius * Math.cos(clusterTheta)
                );
                const galaxyInCluster = 3 + Math.floor(Math.random() * 5);
                for (let g = 0; g < galaxyInCluster; g++) {
                    const particleCount = 25 + Math.floor(Math.random() * 25);
                    const clusterPositions = new Float32Array(particleCount * 3);
                    const clusterColors = new Float32Array(particleCount * 3);
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100
                    );

                    const centerColor = new THREE.Color(0xffaa55);
                    const outerColor = new THREE.Color(0x55aaff);
                    const galaxyRadius = 50;

                    for (let i = 0; i < particleCount; i++) {
                        const r = Math.random() * galaxyRadius;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;

                        clusterPositions[i * 3] = clusterCenter.x + offset.x + r * Math.sin(theta) * Math.cos(phi);
                        clusterPositions[i * 3 + 1] = clusterCenter.y + offset.y + r * Math.sin(theta) * Math.sin(phi);
                        clusterPositions[i * 3 + 2] = clusterCenter.z + offset.z + r * Math.cos(theta);

                        const color = centerColor.clone().lerp(outerColor, r / galaxyRadius);

                        clusterColors[i * 3] = color.r;
                        clusterColors[i * 3 + 1] = color.g;
                        clusterColors[i * 3 + 2] = color.b;
                    }
                    const clusterGeometry = new THREE.BufferGeometry();
                    clusterGeometry.setAttribute('position', new THREE.BufferAttribute(clusterPositions, 3));
                    clusterGeometry.setAttribute('color', new THREE.BufferAttribute(clusterColors, 3));
                    const clusterMaterial = new THREE.PointsMaterial({
                        vertexColors: true,
                        size: 0.1 + Math.random() * 0.3,
                        sizeAttenuation: true,
                        transparent: true,
                        opacity: 0.5,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        fog: false
                    });
                    const clusterField = new THREE.Points(clusterGeometry, clusterMaterial);
                    scene.add(clusterField);
                }
            }

            const distantGalaxyCount = isMobile ? 50 : 300;
            for (let g = 0; g < distantGalaxyCount; g++) {
                const particleCount = 50 + Math.floor(Math.random() * 50);
                const galaxyRadius = 2000 + Math.random() * 1000;
                const galaxyTheta = Math.acos(2 * Math.random() - 1);
                const galaxyPhi = Math.random() * 2 * Math.PI;
                const distantPositions = new Float32Array(particleCount * 3);
                const distantColors = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const r = Math.random() * 30;
                    const theta = Math.acos(2 * Math.random() - 1);
                    const phi = Math.random() * 2 * Math.PI;
                    distantPositions[i * 3] = galaxyRadius * Math.sin(galaxyTheta) * Math.cos(galaxyPhi) + r * Math.sin(theta) * Math.cos(phi);
                    distantPositions[i * 3 + 1] = galaxyRadius * Math.sin(galaxyTheta) * Math.sin(galaxyPhi) + r * Math.sin(theta) * Math.sin(phi);
                    distantPositions[i * 3 + 2] = galaxyRadius * Math.cos(galaxyTheta) + r * Math.cos(theta);
                    const color = randomColor();
                    distantColors[i * 3] = color.r;
                    distantColors[i * 3 + 1] = color.g;
                    distantColors[i * 3 + 2] = color.b;
                }
                const distantGeometry = new THREE.BufferGeometry();
                distantGeometry.setAttribute('position', new THREE.BufferAttribute(distantPositions, 3));
                distantGeometry.setAttribute('color', new THREE.BufferAttribute(distantColors, 3));
                const distantMaterial = new THREE.PointsMaterial({
                    vertexColors: true,
                    size: 2 + Math.random() * 3,
                    transparent: true,
                    opacity: 0.25,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    fog: false
                });
                const distantField = new THREE.Points(distantGeometry, distantMaterial);
                scene.add(distantField);
            }
        }
        createUniverseDetail();

        // カメラアニメーション
        let Flag_CameraAnimation = true;
        let Time_CameraAnimation_Start = null;
        let Position_Trun_Start = null;
        let Elapsed;
        let Radius, Theta, Phi;
        const POSITION_START = new THREE.Vector3(0, 1, 0).multiplyScalar(2000);
        const POSITION_END = new THREE.Vector3(0, 0, 300);
        const DISTANCE_INNER = 30;
        const DURATION_ALL = 20 * 1000;
        const DURATION_INNER = DURATION_ALL * 0.6;
        const DURATION_END = DURATION_ALL * 0.3;
        const DURATION_ADJUST = DURATION_ALL - DURATION_INNER - DURATION_END;
        function Calculate_Bezier(x, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
            let t = 0.5;
            const epsilon = 0.0001;
            const maxIterations = 10;
            for (let i = 0; i < maxIterations; i++) {
                let u = 1 - t;
                let tt = t * t;
                let uu = u * u;
                let uuu = uu * u;
                let ttt = tt * t;
                let currentX = uuu * p0x + 3 * uu * t * p1x + 3 * u * tt * p2x + ttt * p3x;
                let dx = -3 * p0x * uu + 3 * p1x * (1 - 4 * t + 3 * tt) + 3 * p2x * (2 * t - 3 * tt) + 3 * p3x * tt;
                if (Math.abs(x - currentX) < epsilon) break;
                t = t - (currentX - x) / dx;
                t = Math.max(0, Math.min(1, t));
            }
            let u = 1 - t;
            let tt = t * t;
            let uu = u * u;
            let uuu = uu * u;
            let ttt = tt * t;
            return uuu * p0y + 3 * uu * t * p1y + 3 * u * tt * p2y + ttt * p3y;
        }
        function Calculate_Radius() {
            if (Elapsed < DURATION_INNER) {
                const progress = Elapsed / DURATION_INNER;
                const distanceFactor = Calculate_Bezier(progress, 0, 1, 0.4, 1, 0.6, 0, 1, 0);
                Radius = POSITION_START.length() * distanceFactor + DISTANCE_INNER * (1 - distanceFactor);
            } else if (Elapsed < DURATION_ALL) {
                const progress = (Elapsed - DURATION_INNER) / DURATION_END;
                const distanceFactor = Calculate_Bezier(progress, 0, 0, 0.9, 0.1, 0.7, 0.7, 1, 1);
                const startDistance = DISTANCE_INNER;
                const endDistance = POSITION_END.length();
                Radius = startDistance * (1 - distanceFactor) + endDistance * distanceFactor;
            }
        }
        function Calculate_Theta() {
            if (Elapsed < DURATION_INNER) {
                const progress = Elapsed / DURATION_INNER;
                Theta = Math.PI * 0.5 - Math.PI * (90 / 180) * Calculate_Bezier(progress, 0, 0, 0.4, 0, 0.4, 0, 1, 1);
            } else if (Elapsed > DURATION_INNER + DURATION_END && Elapsed < DURATION_ALL) {
                const progress = (Elapsed - DURATION_INNER - DURATION_END) / DURATION_ADJUST;
                Theta = Math.PI * (10 / 180) * Calculate_Bezier(progress, 0, 0, 0.4, 0, 0.3, 1, 1, 1);
            }
        }
        function Calculate_Phi() {
            if (Elapsed < DURATION_INNER) {
                const progress = Elapsed / DURATION_INNER;
                Phi = Math.PI * 4 * Calculate_Bezier(progress, 0, 0, 0.4, 0, 0.4, 0, 1, 1);
            } else if (Elapsed < DURATION_INNER + DURATION_END) {
                const progress = (Elapsed - DURATION_INNER) / DURATION_END;
                Phi = Math.PI * 2 * Calculate_Bezier(progress, 0, 0, 0, 0.2, 0.8, 0.1, 1, 1);
            } else if (Elapsed < DURATION_ALL) {
                const progress = (Elapsed - DURATION_INNER - DURATION_END) / DURATION_ADJUST;
                Phi = Math.PI * (120 / 180) * Calculate_Bezier(progress, 0, 0, 0, 0.4, 0.4, 0.9, 1, 1);
            }
        }

        // ブラックホール
        const blackholeGeometry = new THREE.SphereGeometry(5, 128, 128);
        const blackholeShaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                baseColor: { value: new THREE.Color(0x000000) },
                envMap: { value: envMap },
                viewPos: { value: camera.position },
                cameraDistance: { value: 0.0 },
                noiseScale: { value: 0.8 },
                noiseStrength: { value: 0.1 },
                flowSpeed: { value: 0.3 },
                fresnelPower: { value: 3.0 },
                fresnelScale: { value: 1.2 },
                fresnelBias: { value: 0.05 },
                specularStrength: { value: 0.15 },
                shininess: { value: 40.0 },
                scatteringStrength: { value: 1 },
                rimPower: { value: 2.5 },
                rimStrength: { value: 0.2 },
                rimColor: { value: new THREE.Color(0xff0000) }
            },
            vertexShader: `
            varying vec3 vNormal;
            varying vec3 vWorldPosition;
            varying vec3 vViewPosition;
            uniform float time;
            uniform float noiseScale;
            uniform float noiseStrength;
            uniform float flowSpeed;

            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(
                          i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            vec3 curlNoise(vec3 p) {
                const float e = 0.1;
                vec3 dx = vec3(e, 0.0, 0.0);
                vec3 dy = vec3(0.0, e, 0.0);
                vec3 dz = vec3(0.0, 0.0, e);

                float n0 = snoise(p);
                float n1 = snoise(p + dx);
                float n2 = snoise(p - dx);
                float n3 = snoise(p + dy);
                float n4 = snoise(p - dy);
                float n5 = snoise(p + dz);
                float n6 = snoise(p - dz);

                float dNdx = (n1 - n2) / (2.0 * e);
                float dNdy = (n3 - n4) / (2.0 * e);
                float dNdz = (n5 - n6) / (2.0 * e);

                vec3 curl;
                curl.x = dNdy - dNdz;
                curl.y = dNdz - dNdx;
                curl.z = dNdx - dNdy;

                return normalize(curl);
            }

            void main() {
                vec3 pos = position;
                vec3 noisePos = pos * noiseScale + time * flowSpeed;
                vec3 curl = curlNoise(noisePos);
                pos += curl * noiseStrength;
                vNormal = normalize(normalMatrix * (normal + curl * noiseStrength));
                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vWorldPosition = worldPosition.xyz;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
            fragmentShader: `
            uniform float time;
            uniform vec3 baseColor;
            uniform samplerCube envMap;
            uniform vec3 viewPos;
            uniform float cameraDistance;
            uniform float fresnelPower;
            uniform float fresnelScale;
            uniform float fresnelBias;
            uniform float specularStrength;
            uniform float shininess;
            uniform float scatteringStrength;
            uniform float rimPower;
            uniform float rimStrength;
            uniform vec3 rimColor;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;
            varying vec3 vViewPosition;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(viewPos - vWorldPosition);
                float distanceFactor = clamp(8.0 / cameraDistance, 0.3, 1.0);
                float fresnel = fresnelBias + fresnelScale * pow(1.0 - max(dot(normal, viewDir), 0.0), fresnelPower);
                fresnel *= distanceFactor;
                float rim = rimStrength * pow(1.0 - max(dot(normal, viewDir), 0.0), rimPower);
                rim *= distanceFactor;
                vec3 reflectDir = reflect(-viewDir, normal);
                vec3 reflection = textureCube(envMap, reflectDir).rgb;
                reflection *= distanceFactor;
                vec3 lightDir = normalize(vec3(5.0, 5.0, 5.0));
                vec3 halfwayDir = normalize(lightDir + viewDir);
                float spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);
                vec3 specular = specularStrength * spec * vec3(1.0);
                specular *= distanceFactor;
                float scatter = scatteringStrength * (1.0 - max(dot(normal, viewDir), 0.0));
                vec3 color = baseColor + reflection * fresnel + specular;
                color += vec3(0.1, 0.2, 0.3) * scatter;
                color += rim * rimColor;
                float alpha = 0.25;
                gl_FragColor = vec4(color, alpha);
            }
        `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const blackhole = new THREE.Mesh(blackholeGeometry, blackholeShaderMaterial);
        blackhole.position.set(0, 0, 0);
        blackhole.scale.set(0.9, 0.9, 0.9);
        blackhole.castShadow = false;
        blackhole.receiveShadow = false;
        scene.add(blackhole);
        let textMesh1, textMeshMouthClosed, textMeshMouthOpen;
        const loader = new THREE.FontLoader();
        loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
            const textGeometry1 = new THREE.TextGeometry('. .', { font: font, size: 4, height: 0.25, curveSegments: 2, bevelEnabled: true, bevelThickness: 0, bevelSize: 0.02, bevelOffset: 0, bevelSegments: 0 });
            const textGeometryMouthClosed = new THREE.TextGeometry('-', { font: font, size: 2, height: 0.25, curveSegments: 2, bevelEnabled: true, bevelThickness: 0, bevelSize: 0.02, bevelOffset: 0, bevelSegments: 0 });
            const textGeometryMouthOpen = new THREE.TextGeometry('Ο', { font: font, size: 1, height: 0.25, curveSegments: 2, bevelEnabled: true, bevelThickness: 0, bevelSize: 0.02, bevelOffset: 0, bevelSegments: 0 });

            const textMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ff00,
                emissive: 0x00ffcc,
                emissiveIntensity: 0.5,
                shininess: 100,
                fog: false
            });

            textMesh1 = new THREE.Mesh(textGeometry1, textMaterial);
            textMeshMouthClosed = new THREE.Mesh(textGeometryMouthClosed, textMaterial);
            textMeshMouthOpen = new THREE.Mesh(textGeometryMouthOpen, textMaterial);

            textGeometry1.computeBoundingBox();
            const textWidth1 = textGeometry1.boundingBox.max.x - textGeometry1.boundingBox.min.x;
            textMesh1.position.set(-textWidth1 / 2, 0, 0);

            textGeometryMouthClosed.computeBoundingBox();
            const textWidthClosed = textGeometryMouthClosed.boundingBox.max.x - textGeometryMouthClosed.boundingBox.min.x;
            textMeshMouthClosed.position.set(-textWidthClosed / 2, -1, 0);

            textGeometryMouthOpen.computeBoundingBox();
            const textWidthOpen = textGeometryMouthOpen.boundingBox.max.x - textGeometryMouthOpen.boundingBox.min.x;
            textMeshMouthOpen.position.set(-textWidthOpen / 2, -1, 0);

            textMeshMouthOpen.visible = false;

            scene.add(textMesh1);
            scene.add(textMeshMouthClosed);
            scene.add(textMeshMouthOpen);

            const light = new THREE.PointLight(0x00ffcc, 1);
            light.position.set(0, 0, 5);
            scene.add(light);
        });
        const jetLength = 200;
        const jetRadius = 4;
        const jetRadiusInner = 0.01;
        const jetOffset = 6;
        const jetSegments = 64;
        const jetMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                color: { value: new THREE.Color(0x00aaff) },
                innerColor: { value: new THREE.Color(0xffffff) },
                glowColor: { value: new THREE.Color(0x0088ff) }
            },
            vertexShader: `
                uniform float time;
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying float vY;
                varying float vDistance;
                
                void main() {
                    vPosition = position;
                    vNormal = normal;
                    vY = position.y;
                    vec3 pos = position;
                    
                    vDistance = length(pos.xz);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                uniform vec3 innerColor;
                uniform vec3 glowColor;
                uniform float time;
                varying vec3 vPosition;
                varying vec3 vNormal;
                varying float vY;
                varying float vDistance;
                
                void main() {
                    // 中心からの距離（実際の半径に合わせて調整）
                    float dist = vDistance;
                    float maxRadius = 5.75; // jetRadius * 1.15
                    float normalizedDist = dist / maxRadius;
                    
                    // 中心部は白、外側は青にグラデーション
                    vec3 finalColor = mix(innerColor * 1.5, color * 2.0, smoothstep(0.0, 0.6, normalizedDist)); // 白の強さを半分に
                    
                    // 外側のグロー効果（青い光）
                    float glow = 1.0 - smoothstep(0.3, 1.2, normalizedDist);
                    finalColor += glowColor * glow * 1.5;
                    
                    // Y軸方向の濃淡：中心付近（vY = 0）が濃く、上下の端に向かって薄くなる
                    // vYは-100から100の範囲（jetLength/2 = 100）
                    float yNormalized = abs(vY) / 100.0; // 0.0（中心）から1.0（端）に正規化
                    float yIntensity = 1.0 - smoothstep(0.0, 1.0, yNormalized);
                    // 中心付近をより強調
                    yIntensity = mix(yIntensity, 1.0, 1.0 - smoothstep(0.0, 0.3, yNormalized));
                    
                    // 半径方向のアルファ値：中心が濃く、外側に向かって薄くなる
                    float radialAlpha = 1.0 - smoothstep(0.0, 1.0, normalizedDist);
                    
                    // 外側の端で完全にフェードアウト（境目が見えないように）
                    float edgeFade = smoothstep(0.7, 1.0, normalizedDist);
                    radialAlpha *= (1.0 - edgeFade);
                    
                    // 最終的なアルファ値：半径方向とY軸方向の両方を考慮
                    float alpha = radialAlpha * yIntensity * 0.5; // 強さを半分に
                    
                    // 色を明るく
                    finalColor = min(finalColor, vec3(4.0));
                    
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const jetGeometryTop = new THREE.CylinderGeometry(jetRadius * 1.15, jetRadiusInner, jetLength, jetSegments, 1, true);
        const jetTop = new THREE.Mesh(jetGeometryTop, jetMaterial);
        jetTop.position.set(0, jetOffset + jetLength / 2, 0);
        scene.add(jetTop);
        const jetGeometryBottom = new THREE.CylinderGeometry(jetRadiusInner, jetRadius * 1.15, jetLength, jetSegments, 1, true);
        const jetBottom = new THREE.Mesh(jetGeometryBottom, jetMaterial);
        jetBottom.position.set(0, -jetOffset - jetLength / 2, 0);
        scene.add(jetBottom);
        const messages = [
            "やぁ！",
            "ようこそ！FUM Websiteへ！",
            "調子はどう？",
            "ん...何かよう？",
            "宇宙はひろいなぁ～。",
            "冒険しようよ！",
            "新しいことを学ぶのって楽しいよね！",
            "SpaceX。かっこいいよね！わかるぅ～！",
            "それぞれの場ってどうやって繋がってるんだろう？",
            "宇宙生物って絶対いるよね！",
            "君も宇宙に行きたいの？",
            "...あれ？...ボクのこと見えてるの？",
            "ボクの中ってどうなってると思う？",
            "FUMはたぶん元気だよ。",
            "FUMはたぶん退屈なんだよ。"
        ];
        const MESSAGE_DISTANCE_THRESHOLD = 35;
        let messageVisible = false;
        let messageCooldown = false;
        let isFirstMessage = true;
        function updateSpeechBubble() {
            if (!blackhole || !vue) return;

            const distance = camera.position.distanceTo(blackhole.position);

            if (distance < MESSAGE_DISTANCE_THRESHOLD && !messageVisible && !messageCooldown) {
                messageVisible = true;
                messageCooldown = true;
                vue.ShowMessage = true;

                if (isFirstMessage) {
                    vue.CurrentMessage = messages[0];
                    isFirstMessage = false;
                } else {
                    const randomIndex = Math.floor(Math.random() * messages.length);
                    vue.CurrentMessage = messages[randomIndex];
                }

                setTimeout(() => {
                    messageVisible = false;
                    vue.ShowMessage = false;
                    setTimeout(() => {
                        messageCooldown = false;
                    }, 3000);
                }, 4000);
            }

            if (vue.ShowMessage) {
                const screenPosition = blackhole.position.clone().project(camera);
                const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                const MAX_DISTANCE = MESSAGE_DISTANCE_THRESHOLD;
                const MIN_DISTANCE = 15;
                const currentDistance = camera.position.distanceTo(blackhole.position);
                let proximityFactor = (MAX_DISTANCE - currentDistance) / (MAX_DISTANCE - MIN_DISTANCE);
                proximityFactor = Math.max(0, Math.min(1, proximityFactor));
                const yOffsetFar = 0.45;
                const yOffsetClose = 0.38;
                const dynamicOffsetY = yOffsetFar + (yOffsetClose - yOffsetFar) * proximityFactor;
                const y = (-screenPosition.y * 0.5 + dynamicOffsetY) * window.innerHeight;

                vue.MessageStyle = {
                    top: `${y}px`,
                    left: `${x}px`
                };
            }
        }
        let blinkTimer = 0;
        function updateFace(delta) {
            blinkTimer += delta;
            if (blinkTimer > 3 + Math.random() * 3) {
                if (textMesh1) textMesh1.visible = false;

                setTimeout(() => {
                    if (textMesh1) textMesh1.visible = true;
                }, 120);

                blinkTimer = 0;
            }
            if (vue && vue.ShowMessage && textMeshMouthClosed && textMeshMouthOpen) {
                const isMouthOpen = Math.floor(time * 2) % 2 === 0;
                textMeshMouthClosed.visible = !isMouthOpen;
                textMeshMouthOpen.visible = isMouthOpen;
            } else if (textMeshMouthClosed && textMeshMouthOpen) {
                textMeshMouthClosed.visible = true;
                textMeshMouthOpen.visible = false;
            }
        }
        const particleCount = 1000;
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount);
        const lifetimes = new Float32Array(particleCount);
        const coneAngle = Math.PI / 40;
        const jetSpeed = 2;
        const velocitiesX = new Float32Array(particleCount);
        const velocitiesY = new Float32Array(particleCount);
        const velocitiesZ = new Float32Array(particleCount);
        for (let i = 0; i < particleCount; i++) {
            resetParticle(i);
        }
        function resetParticle(i) {
            const isTop = Math.random() > 0.5;

            positions[i * 3 + 0] = 0;
            positions[i * 3 + 1] = isTop ? jetOffset : -jetOffset;
            positions[i * 3 + 2] = 0;

            const theta = Math.random() * Math.PI * 2;
            const spread = Math.random() * Math.tan(coneAngle);

            const vx = Math.cos(theta) * spread;
            const vz = Math.sin(theta) * spread;
            const vy = isTop ? 1 : -1;

            const len = Math.sqrt(vx * vx + vy * vy + vz * vz);

            velocitiesX[i] = (vx / len) * jetSpeed;
            velocitiesY[i] = (vy / len) * jetSpeed;
            velocitiesZ[i] = (vz / len) * jetSpeed;

            lifetimes[i] = Math.random() * 80;
        }
        particleGeometry.setAttribute(
            'position',
            new THREE.BufferAttribute(positions, 3)
        );
        const particleMaterial = new THREE.PointsMaterial({
            color: 0x88ccff,
            size: 0.1,
            transparent: true,
            opacity: 0.75,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const jetParticles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(jetParticles);
        function updateJetParticles() {
            const pos = particleGeometry.attributes.position.array;

            for (let i = 0; i < particleCount; i++) {
                pos[i * 3 + 0] += velocitiesX[i];
                pos[i * 3 + 1] += velocitiesY[i];
                pos[i * 3 + 2] += velocitiesZ[i];

                lifetimes[i]--;

                if (
                    lifetimes[i] <= 0 ||
                    Math.abs(pos[i * 3 + 1]) > jetLength * 0.9
                ) {
                    resetParticle(i);
                }
            }

            particleGeometry.attributes.position.needsUpdate = true;
        }


        // ポストエフェクト
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight));
        bloomPass.threshold = 0;
        if (isMobile) {
            bloomPass.strength = 0.6;
            bloomPass.radius = 0.1;
        } else {
            bloomPass.strength = 0.8;
            bloomPass.radius = 0.6;
        }
        composer.addPass(bloomPass);
        const DigitalGlitchShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'tDisp': { value: null },
                'byp': { value: 0 },
                'amount': { value: 0.08 },
                'angle': { value: 0.02 },
                'seed': { value: 0.02 },
                'seed_x': { value: 0.02 },
                'seed_y': { value: 0.02 },
                'distortion_x': { value: 0.5 },
                'distortion_y': { value: 0.6 },
                'col_s': { value: 0.05 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform int byp;
                uniform sampler2D tDiffuse;
                uniform sampler2D tDisp;
                uniform float amount;
                uniform float angle;
                uniform float seed;
                float seed_x;
                uniform float seed_y;
                uniform float distortion_x;
                uniform float distortion_y;
                uniform float col_s;
                varying vec2 vUv;

                float rand(vec2 co) {
                    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
                }

                void main() {
                    if (byp < 1) {
                        vec2 p = vUv;
                        if (amount > 0.0) {
                            float xs = floor(gl_FragCoord.x / 0.5);
                            float ys = floor(gl_FragCoord.y / 0.5);
                            vec4 normal = texture2D(tDisp, p * seed * seed);
                            if (p.y < distortion_x + col_s && p.y > distortion_x - col_s * seed) {
                                if (seed_x > 0.0) {
                                    p.y = 1.0 - (p.y + distortion_y);
                                } else {
                                    p.y = distortion_y;
                                }
                            }
                            if (p.x < distortion_y + col_s && p.x > distortion_y - col_s * seed) {
                                if (seed_y > 0.0) {
                                    p.x = distortion_x;
                                } else {
                                    p.x = 1.0 - (p.x + distortion_x);
                                }
                            }
                            p.x += normal.x * seed_x * (seed / 5.0);
                            p.y += normal.y * seed_y * (seed / 5.0);
                            vec2 offset = amount * vec2(cos(angle), sin(angle));
                            vec4 cr = texture2D(tDiffuse, p + offset);
                            vec4 cga = texture2D(tDiffuse, p);
                            vec4 cb = texture2D(tDiffuse, p - offset);
                            gl_FragColor = vec4(cr.r, cga.g, cb.b, 1.0);
                        } else {
                            gl_FragColor = texture2D(tDiffuse, p);
                        }
                    } else {
                        gl_FragColor = texture2D(tDiffuse, vUv);
                    }
                }
            `
        };
        function generateNoiseTextureForGlitch(size = 64) {
            const data = new Uint8Array(size * size * 4);
            for (let i = 0; i < size * size * 4; i++) {
                data[i] = Math.random() * 255;
            }
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.needsUpdate = true;
            return texture;
        }
        let glitchPass;
        glitchPass = new THREE.ShaderPass(DigitalGlitchShader);
        glitchPass.uniforms.tDisp.value = generateNoiseTextureForGlitch();
        glitchPass.renderToScreen = true;
        composer.addPass(glitchPass);
        let isGlitching = false;
        let glitchTimeout;
        function updateGlitch() {
            if (isGlitching) {
                glitchPass.uniforms.seed.value = Math.random();
                glitchPass.uniforms.amount.value = Math.random() * 0.1 + 0.02;
                glitchPass.uniforms.angle.value = Math.random() * 2;
                glitchPass.uniforms.seed_x.value = (Math.random() > 0.5 ? 0.02 : -0.02);
                glitchPass.uniforms.seed_y.value = (Math.random() > 0.5 ? 0.02 : -0.02);
                glitchPass.uniforms.distortion_x.value = Math.random() * 0.5;
                glitchPass.uniforms.distortion_y.value = Math.random() * 0.5;
                glitchPass.uniforms.col_s.value = Math.random() * 0.05;
            } else {
                glitchPass.uniforms.amount.value = 0;
            }
        }
        function triggerGlitch() {
            isGlitching = true;
            clearTimeout(glitchTimeout);
            const duration = (Math.random() - 0.5) * 500;
            glitchTimeout = setTimeout(() => {
                isGlitching = false;
            }, duration);
            const nextTrigger = Math.random() * 5000 + 3000;
            setTimeout(triggerGlitch, nextTrigger);
        }
        setTimeout(triggerGlitch, 2000);


        // アニメーション
        const clock = new THREE.Clock();
        let time = 0.0;
        let countDistance = Math.PI;
        let countTheata = Math.PI;
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const currentTime = performance.now();
            time += delta;

            // カメラアニメーション
            if (Flag_CameraAnimation) {
                if (Time_CameraAnimation_Start === null) {
                    Time_CameraAnimation_Start = currentTime;
                    Position_Trun_Start = camera.position.clone();
                }
                Elapsed = currentTime - Time_CameraAnimation_Start;
                if (Elapsed < DURATION_ALL) {
                    Calculate_Radius();
                    Calculate_Theta();
                    Calculate_Phi();
                    const x = Radius * Math.cos(Theta) * Math.cos(Phi);
                    const y = Radius * Math.sin(Theta);
                    const z = Radius * Math.cos(Theta) * Math.sin(Phi);
                    camera.position.set(x, y, z);
                    camera.lookAt(0, 0, 0);
                }
                if (Elapsed > DURATION_ALL) {
                    Flag_CameraAnimation = false;
                    controls.maxDistance = 1200;
                    controls.enabled = true;
                }
            } else {
                countDistance += Math.PI * 0.01 * delta;
                const currentDistance = camera.position.length();
                let newDistance = currentDistance + Math.sin(countDistance) * 2 * delta;
                if (newDistance < 18) {
                    newDistance = 18;
                    countDistance += Math.PI * delta;
                }
                const currentPhi = Math.atan2(camera.position.z, camera.position.x);
                const newPhi = currentPhi + Math.PI * 0.05 * delta;
                countTheata += Math.PI * 0.2 * delta;
                let currentTheta = Math.asin(camera.position.y / newDistance);
                if (currentTheta <= -Math.PI * 0.49) {
                    currentTheta = -Math.PI * 0.49;
                }
                if (currentTheta >= Math.PI * 0.49) {
                    currentTheta = Math.PI * 0.49;
                }
                const newTheta = currentTheta + Math.sin(countTheata) * Math.PI * 2.5 / 180 * delta;
                const x = newDistance * Math.cos(newTheta) * Math.cos(newPhi);
                const y = newDistance * Math.sin(newTheta);
                const z = newDistance * Math.cos(newTheta) * Math.sin(newPhi);
                camera.position.set(x, y, z);
                camera.lookAt(0, 0, 0);
            }

            // ブラックホール
            blackholeShaderMaterial.uniforms.time.value = time;
            blackholeShaderMaterial.uniforms.viewPos.value.copy(camera.position);
            blackholeShaderMaterial.uniforms.cameraDistance.value = camera.position.length();
            updateFace(delta);
            updateSpeechBubble();
            updateJetParticles();

            // ポストエフェクト
            updateGlitch();

            controls.update();
            composer.render();
        }
        animate();
    </script>

</body>

</html>