<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="author" content="F U M">
    <meta name="description" content="FUM WebSite: 様々な内容を学べるサイト。">
    <meta name="robots" content="index, follow">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-B89KY0993B"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-B89KY0993B');
    </script>

    <link rel="icon" type="image/x-icon" href="../../Asset/Image/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../../Asset/Image/Icon_1_2.jpg">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP:100,300,400,500,700,900&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@7.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="../../Asset/CSS/Common.css" rel="stylesheet" />
    <link href="../../Asset/CSS/Index.css" rel="stylesheet" />

    <title>F U M</title>
</head>

<body>
    <canvas id="ElectronShell"></canvas>

    <v-app id="App">
        <template>
            <main-system-bar :drawer="Drawer" @change-drawer="ChangeDrawer">Home</main-system-bar>

            <v-main id="Main">
                <transition name="Fade_Page">
                    <v-container v-show="Ready_Page" fluid fill-height class="pa-5" style="align-content: flex-start;">
                        <v-container id="TextFlow">
                            <span style="color: red"> &lt;NEWS&gt; </span> 
                            <span style="color: rgb(200, 200, 200)">
                                June to July is the rainy season! Humid air sweeps across Japan. Umbrellas and raincoats
                                are a must! Watch out for food poisoning and flooding.
                            </span>
                        </v-container>
                    </v-container>
                </transition>
            </v-main>

            <main-navigation :drawer="Drawer" @change-drawer="ChangeDrawer"></main-navigation>
            <main-footer-simple></main-footer-simple>
        </template>
    </v-app>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.js"></script>
    <script src="../../Asset/Javascript/Common.js"></script>
    <script src="../../Asset/Javascript/Index.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let vue = new Vue({
            el: '#App',
            vuetify: new Vuetify(),
            mixins: [window.Mixins_Common, window.Mixins_Index],
        })
    </script>

    <script type="module">
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x020202, 0, 5000);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector("#ElectronShell"),
            antialias: true
        });
        renderer.setClearColor(0x010104, 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.5;

        const isMobile = window.innerWidth <= 768;

        function generateNoiseTexture(width = 256, height = 256) {
            const size = width * height;
            const data = new Uint8Array(size * 4);
            for (let i = 0; i < size; i++) {
                const value = Math.random() * 255;
                data[i * 4] = value;
                data[i * 4 + 1] = value;
                data[i * 4 + 2] = value;
                data[i * 4 + 3] = 255;
            }
            const texture = new THREE.DataTexture(data, width, height, THREE.RGBAFormat);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.needsUpdate = true;
            return texture;
        }

        const voidTexture = generateNoiseTexture();
        const voidBackground = new THREE.Mesh(
            new THREE.SphereGeometry(3000, 32, 32),
            new THREE.MeshBasicMaterial({
                map: voidTexture,
                side: THREE.BackSide,
                opacity: 0.2,
                transparent: true,
                color: 0x020206,
                fog: false
            })
        );
        scene.add(voidBackground);

        const loader = new THREE.FontLoader();
        loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
            const textGeometry = new THREE.TextGeometry('^._.^', {
                font: font,
                size: 2,
                height: 0.25,
                curveSegments: 2,
                bevelEnabled: true,
                bevelThickness: 0,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 0
            });

            const textMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ff00,
                emissive: 0x00ffcc,
                emissiveIntensity: 0.5,
                shininess: 100,
                fog: true
            });

            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textGeometry.computeBoundingBox();
            const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
            textMesh.position.set(-textWidth / 2 - 0.35, 0, 0);
            scene.add(textMesh);

            const light = new THREE.PointLight(0x00ffcc, 1);
            light.position.set(0, 0, 5);
            scene.add(light);
        });

        function createProceduralCubeMap() {
            const size = 64;
            const images = [];
            for (let i = 0; i < 6; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
                gradient.addColorStop(0, 'rgba(8, 25, 45, 255)');
                gradient.addColorStop(1, 'rgba(1, 3, 8, 255)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                images.push(canvas);
            }
            const cubeTexture = new THREE.CubeTexture(images);
            cubeTexture.format = THREE.RGBAFormat;
            cubeTexture.needsUpdate = true;
            return cubeTexture;
        }

        const envMap = createProceduralCubeMap();

        const liquidSphereGeometry = new THREE.SphereGeometry(3, 256, 256);
        const liquidShaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                baseColor: { value: new THREE.Color(0x0077cc) },
                envMap: { value: envMap },
                viewPos: { value: camera.position },
                cameraDistance: { value: 0.0 },
                noiseScale: { value: 0.8 },
                noiseStrength: { value: 0.1 },
                flowSpeed: { value: 0.3 },
                fresnelPower: { value: 3.0 },
                fresnelScale: { value: 1.2 },
                fresnelBias: { value: 0.05 },
                specularStrength: { value: 0.15 },
                shininess: { value: 40.0 },
                scatteringStrength: { value: 1 },
                rimPower: { value: 2.5 },
                rimStrength: { value: 0.2 },
                rimColor: { value: new THREE.Color(0x00ccff) }
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vWorldPosition;
                varying vec3 vViewPosition;
                uniform float time;
                uniform float noiseScale;
                uniform float noiseStrength;
                uniform float flowSpeed;

                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute(permute(permute(
                              i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);
                    vec4 x = x_ * ns.x + ns.yyyy;
                    vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                    vec3 p0 = vec3(a0.xy, h.x);
                    vec3 p1 = vec3(a0.zw, h.y);
                    vec3 p2 = vec3(a1.xy, h.z);
                    vec3 p3 = vec3(a1.zw, h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x;
                    p1 *= norm.y;
                    p2 *= norm.z;
                    p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                }

                vec3 curlNoise(vec3 p) {
                    const float e = 0.1;
                    vec3 dx = vec3(e, 0.0, 0.0);
                    vec3 dy = vec3(0.0, e, 0.0);
                    vec3 dz = vec3(0.0, 0.0, e);

                    float n0 = snoise(p);
                    float n1 = snoise(p + dx);
                    float n2 = snoise(p - dx);
                    float n3 = snoise(p + dy);
                    float n4 = snoise(p - dy);
                    float n5 = snoise(p + dz);
                    float n6 = snoise(p - dz);

                    float dNdx = (n1 - n2) / (2.0 * e);
                    float dNdy = (n3 - n4) / (2.0 * e);
                    float dNdz = (n5 - n6) / (2.0 * e);

                    vec3 curl;
                    curl.x = dNdy - dNdz;
                    curl.y = dNdz - dNdx;
                    curl.z = dNdx - dNdy;

                    return normalize(curl);
                }

                void main() {
                    vec3 pos = position;
                    vec3 noisePos = pos * noiseScale + time * flowSpeed;
                    vec3 curl = curlNoise(noisePos);
                    pos += curl * noiseStrength;
                    vNormal = normalize(normalMatrix * (normal + curl * noiseStrength));
                    vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 baseColor;
                uniform samplerCube envMap;
                uniform vec3 viewPos;
                uniform float cameraDistance;
                uniform float fresnelPower;
                uniform float fresnelScale;
                uniform float fresnelBias;
                uniform float specularStrength;
                uniform float shininess;
                uniform float scatteringStrength;
                uniform float rimPower;
                uniform float rimStrength;
                uniform vec3 rimColor;
                varying vec3 vNormal;
                varying vec3 vWorldPosition;
                varying vec3 vViewPosition;

                void main() {
                    vec3 normal = normalize(vNormal);
                    vec3 viewDir = normalize(viewPos - vWorldPosition);
                    float distanceFactor = clamp(8.0 / cameraDistance, 0.3, 1.0);
                    float fresnel = fresnelBias + fresnelScale * pow(1.0 - max(dot(normal, viewDir), 0.0), fresnelPower);
                    fresnel *= distanceFactor;
                    float rim = rimStrength * pow(1.0 - max(dot(normal, viewDir), 0.0), rimPower);
                    rim *= distanceFactor;
                    vec3 reflectDir = reflect(-viewDir, normal);
                    vec3 reflection = textureCube(envMap, reflectDir).rgb;
                    reflection *= distanceFactor;
                    vec3 lightDir = normalize(vec3(5.0, 5.0, 5.0));
                    vec3 halfwayDir = normalize(lightDir + viewDir);
                    float spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);
                    vec3 specular = specularStrength * spec * vec3(1.0);
                    specular *= distanceFactor;
                    float scatter = scatteringStrength * (1.0 - max(dot(normal, viewDir), 0.0));
                    vec3 color = baseColor + reflection * fresnel + specular;
                    color += vec3(0.1, 0.2, 0.3) * scatter;
                    color += rim * rimColor;
                    float alpha = 0.25;
                    gl_FragColor = vec4(color, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const liquidSphere = new THREE.Mesh(liquidSphereGeometry, liquidShaderMaterial);
        liquidSphere.position.set(0, 0, 0);
        liquidSphere.scale.set(0.9, 0.9, 0.9);
        liquidSphere.castShadow = false;
        liquidSphere.receiveShadow = false;
        scene.add(liquidSphere);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 0.8;
        controls.enablePan = false;
        controls.maxPolarAngle = Math.PI - 0.1;
        controls.minPolarAngle = 0.1;

        camera.position.copy(new THREE.Vector3(0, 1, 0).multiplyScalar(10000));
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        function easeInOutSloMo(t) {
            return Math.pow(easeInOutCubic(t), 2);
        }

        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();

        const cursorParticles = [];
        const cursorParticleGeometry = new THREE.BufferGeometry();
        const cursorParticleMaterial = new THREE.PointsMaterial({
            color: 0x00ffcc,
            size: isMobile ? 0.1 : 0.05,
            transparent: true,
            opacity: 0.8,
            emissive: 0x00ffcc,
            emissiveIntensity: 2.0
        });

        const electronShells = [
            { name: 'K', electrons: 2, radius: 5 },
            { name: 'L', electrons: 8, radius: 8 },
            { name: 'M', electrons: 18, radius: 11 },
            { name: 'N', electrons: 32, radius: 14 },
            { name: 'O', electrons: 32, radius: 17 }
        ];

        const totalElectrons = electronShells.reduce((sum, shell) => sum + shell.electrons, 0);
        const pointSize = isMobile ? 0.3 : 0.15;
        const connectionDistance = Math.PI * 2;
        const avoidanceDistance = 1.2;
        const repulsionStrength = 0.02;

        const pointMaterial = new THREE.PointsMaterial({
            color: 0x00ffcc,
            size: pointSize,
            sizeAttenuation: true,
            emissive: 0x00ffcc,
            emissiveIntensity: 2.0,
            fog: true
        });

        const positions = new Float32Array(totalElectrons * 3);
        const velocities = new Float32Array(totalElectrons * 3);

        const ALPHA = 1 / 137;
        const LIGHT_SPEED = 0.299792458;

        let currentIndex = 0;
        electronShells.forEach((shell, shellIndex) => {
            const baseSpeed = (92 * ALPHA * LIGHT_SPEED / (shellIndex + 1)) * 2;
            for (let i = 0; i < shell.electrons; i++) {
                const golden_ratio = (1 + Math.sqrt(5)) / 2;
                const theta = 2 * Math.PI * i / golden_ratio;
                const phi = Math.acos(1 - 2 * (i + 0.5) / shell.electrons);

                const x = shell.radius * Math.sin(phi) * Math.cos(theta);
                const y = shell.radius * Math.sin(phi) * Math.sin(theta);
                const z = shell.radius * Math.cos(phi);

                positions[currentIndex * 3] = x;
                positions[currentIndex * 3 + 1] = y;
                positions[currentIndex * 3 + 2] = z;

                const tangentX = -Math.sin(theta);
                const tangentY = Math.cos(theta);
                const tangentZ = 0;

                velocities[currentIndex * 3] = tangentX * baseSpeed;
                velocities[currentIndex * 3 + 1] = tangentY * baseSpeed;
                velocities[currentIndex * 3 + 2] = tangentZ * baseSpeed;

                currentIndex++;
            }
        });

        const pointGeometry = new THREE.BufferGeometry();
        pointGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const pointCloud = new THREE.Points(pointGeometry, pointMaterial);
        scene.add(pointCloud);

        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: isMobile ? 0.2 : 0.1,
            emissive: 0x00ffff,
            emissiveIntensity: 1.5,
            fog: true
        });

        const lineGeometry = new THREE.BufferGeometry();
        scene.add(new THREE.LineSegments(lineGeometry, lineMaterial));

        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight));
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2;
        bloomPass.radius = 1.0;
        composer.addPass(bloomPass);

        const DigitalGlitchShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'tDisp': { value: null },
                'byp': { value: 0 },
                'amount': { value: 0.08 },
                'angle': { value: 0.02 },
                'seed': { value: 0.02 },
                'seed_x': { value: 0.02 },
                'seed_y': { value: 0.02 },
                'distortion_x': { value: 0.5 },
                'distortion_y': { value: 0.6 },
                'col_s': { value: 0.05 }
            },
            vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
            fragmentShader: `
            uniform int byp;
            uniform sampler2D tDiffuse;
            uniform sampler2D tDisp;
            uniform float amount;
            uniform float angle;
            uniform float seed;
            float seed_x;
            uniform float seed_y;
            uniform float distortion_x;
            uniform float distortion_y;
            uniform float col_s;
            varying vec2 vUv;

            float rand(vec2 co) {
                return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                if (byp < 1) {
                    vec2 p = vUv;
                    if (amount > 0.0) {
                        float xs = floor(gl_FragCoord.x / 0.5);
                        float ys = floor(gl_FragCoord.y / 0.5);
                        vec4 normal = texture2D(tDisp, p * seed * seed);
                        if (p.y < distortion_x + col_s && p.y > distortion_x - col_s * seed) {
                            if (seed_x > 0.0) {
                                p.y = 1.0 - (p.y + distortion_y);
                            } else {
                                p.y = distortion_y;
                            }
                        }
                        if (p.x < distortion_y + col_s && p.x > distortion_y - col_s * seed) {
                            if (seed_y > 0.0) {
                                p.x = distortion_x;
                            } else {
                                p.x = 1.0 - (p.x + distortion_x);
                            }
                        }
                        p.x += normal.x * seed_x * (seed / 5.0);
                        p.y += normal.y * seed_y * (seed / 5.0);
                        vec2 offset = amount * vec2(cos(angle), sin(angle));
                        vec4 cr = texture2D(tDiffuse, p + offset);
                        vec4 cga = texture2D(tDiffuse, p);
                        vec4 cb = texture2D(tDiffuse, p - offset);
                        gl_FragColor = vec4(cr.r, cga.g, cb.b, 1.0);
                    } else {
                        gl_FragColor = texture2D(tDiffuse, p);
                    }
                } else {
                    gl_FragColor = texture2D(tDiffuse, vUv);
                }
            }
        `
        };

        function generateNoiseTextureForGlitch(size = 64) {
            const data = new Uint8Array(size * size * 4);
            for (let i = 0; i < size * size * 4; i++) {
                data[i] = Math.random() * 255;
            }
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.needsUpdate = true;
            return texture;
        }

        const glitchPass = new THREE.ShaderPass(DigitalGlitchShader);
        glitchPass.uniforms.tDisp.value = generateNoiseTextureForGlitch();
        glitchPass.renderToScreen = true;
        composer.addPass(glitchPass);

        let isGlitching = false;
        let glitchTimeout;

        function updateGlitch() {
            if (isGlitching) {
                glitchPass.uniforms.seed.value = Math.random();
                glitchPass.uniforms.amount.value = Math.random() * 0.1 + 0.02;
                glitchPass.uniforms.angle.value = Math.random() * 2;
                glitchPass.uniforms.seed_x.value = (Math.random() > 0.5 ? 0.02 : -0.02);
                glitchPass.uniforms.seed_y.value = (Math.random() > 0.5 ? 0.02 : -0.02);
                glitchPass.uniforms.distortion_x.value = Math.random() * 0.5;
                glitchPass.uniforms.distortion_y.value = Math.random() * 0.5;
                glitchPass.uniforms.col_s.value = Math.random() * 0.05;
            } else {
                glitchPass.uniforms.amount.value = 0;
            }
        }

        function triggerGlitch() {
            isGlitching = true;
            clearTimeout(glitchTimeout);
            const duration = (Math.random() - 0.5) * 500;
            glitchTimeout = setTimeout(() => {
                isGlitching = false;
            }, duration);
            const nextTrigger = Math.random() * 5000 + 3000;
            setTimeout(triggerGlitch, nextTrigger);
        }

        setTimeout(triggerGlitch, 2000);

        function createCursorParticle(x, y, z) {
            for (let i = 0; i < 1; i++) {
                const speed = 0.05;
                const particle = {
                    position: new THREE.Vector3(x, y, z),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * speed,
                        (Math.random() - 0.5) * speed,
                        (Math.random() - 0.5) * speed
                    ),
                    life: 1.0
                };
                cursorParticles.push(particle);
            }
        }

        function updateCursorParticles() {
            for (let i = cursorParticles.length - 1; i >= 0; i--) {
                const particle = cursorParticles[i];
                particle.position.add(particle.velocity);
                particle.life -= 0.01;
                if (particle.life <= 0) {
                    cursorParticles.splice(i, 1);
                }
            }
            const positions = new Float32Array(cursorParticles.length * 3);
            cursorParticles.forEach((particle, i) => {
                positions[i * 3] = particle.position.x;
                positions[i * 3 + 1] = particle.position.y;
                positions[i * 3 + 2] = particle.position.z;
            });
            cursorParticleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        }

        const cursorParticleSystem = new THREE.Points(cursorParticleGeometry, cursorParticleMaterial);
        cursorParticleSystem.position.set(0, 0, 0);
        scene.add(cursorParticleSystem);

        function animatePoints() {
            const positions = pointGeometry.attributes.position.array;
            let currentIndex = 0;
            electronShells.forEach((shell, shellIndex) => {
                const shellStartIndex = currentIndex;
                const shellEndIndex = currentIndex + shell.electrons;
                for (let i = shellStartIndex; i < shellEndIndex; i++) {
                    const idx = i * 3;
                    let x = positions[idx];
                    let y = positions[idx + 1];
                    let z = positions[idx + 2];
                    const currentRadius = Math.sqrt(x * x + y * y + z * z);
                    const radiusCorrection = (shell.radius - currentRadius) * 0.1;
                    const radiusVector = {
                        x: x / currentRadius * radiusCorrection,
                        y: y / currentRadius * radiusCorrection,
                        z: z / currentRadius * radiusCorrection
                    };
                    let repulsionX = 0, repulsionY = 0, repulsionZ = 0;
                    for (let j = shellStartIndex; j < shellEndIndex; j++) {
                        if (i !== j) {
                            const dx = x - positions[j * 3];
                            const dy = y - positions[j * 3 + 1];
                            const dz = z - positions[j * 3 + 2];
                            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            if (distance < avoidanceDistance) {
                                const repulsion = (avoidanceDistance - distance) * repulsionStrength;
                                repulsionX += dx / distance * repulsion;
                                repulsionY += dy / distance * repulsion;
                                repulsionZ += dz / distance * repulsion;
                            }
                        }
                    }
                    velocities[idx] += radiusVector.x + repulsionX;
                    velocities[idx + 1] += radiusVector.y + repulsionY;
                    velocities[idx + 2] += radiusVector.z + repulsionZ;
                    positions[idx] += velocities[idx];
                    positions[idx + 1] += velocities[idx + 1];
                    positions[idx + 2] += velocities[idx + 2];
                }
                currentIndex += shell.electrons;
            });
            pointGeometry.attributes.position.needsUpdate = true;
        }

        function updateLines() {
            const positions = pointGeometry.attributes.position.array;
            const linePositions = [];
            for (let i = 0; i < positions.length / 3; i++) {
                for (let j = i + 1; j < positions.length / 3; j++) {
                    const dx = positions[i * 3] - positions[j * 3];
                    const dy = positions[i * 3 + 1] - positions[j * 3 + 1];
                    const dz = positions[i * 3 + 2] - positions[j * 3 + 2];
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    if (distance < connectionDistance) {
                        linePositions.push(
                            positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                            positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
                        );
                    }
                }
            }
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            lineGeometry.computeBoundingSphere();
        }

        const galaxyCount = 50;
        const galaxyPositions = new Float32Array(galaxyCount * 3);
        const galaxyColors = new Float32Array(galaxyCount * 3);
        for (let i = 0; i < galaxyCount; i++) {
            const r = 1000 + Math.random() * 1000;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            galaxyPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            galaxyPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            galaxyPositions[i * 3 + 2] = r * Math.cos(phi);
            const color = new THREE.Color(0xffffff).lerp(new THREE.Color(0x88aaff), Math.random());
            galaxyColors[i * 3] = color.r;
            galaxyColors[i * 3 + 1] = color.g;
            galaxyColors[i * 3 + 2] = color.b;
        }
        const galaxyGeometry = new THREE.BufferGeometry();
        galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(galaxyPositions, 3));
        galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(galaxyColors, 3));
        const galaxyMaterial = new THREE.PointsMaterial({
            vertexColors: true,
            size: isMobile ? 0.2 : 0.1,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.1,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            fog: true
        });
        const galaxySystem = new THREE.Points(galaxyGeometry, galaxyMaterial);
        scene.add(galaxySystem);

        let Flag_CameraAnimation = true;
        let Time_CameraAnimation_Start = null;
        let Position_Trun_Start = null;

        let Elapsed;
        let Radius, Theta, Phi;

        const POSITION_START = new THREE.Vector3(0, 1, 0).multiplyScalar(2000);
        const POSITION_END = new THREE.Vector3(-20, 20, 40);
        const DISTANCE_INNER = 30;

        const DURATION_ALL = 20 * 1000;
        const DURATION_INNER = DURATION_ALL * 0.6;
        const DURATION_END = DURATION_ALL * 0.3;
        const DURATION_ADJUST = DURATION_ALL - DURATION_INNER - DURATION_END;

        function Calculate_Bezier(x, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
            let t = 0.5;
            const epsilon = 0.0001;
            const maxIterations = 10;
            for (let i = 0; i < maxIterations; i++) {
                let u = 1 - t;
                let tt = t * t;
                let uu = u * u;
                let uuu = uu * u;
                let ttt = tt * t;
                let currentX = uuu * p0x + 3 * uu * t * p1x + 3 * u * tt * p2x + ttt * p3x;
                let dx = -3 * p0x * uu + 3 * p1x * (1 - 4 * t + 3 * tt) + 3 * p2x * (2 * t - 3 * tt) + 3 * p3x * tt;
                if (Math.abs(x - currentX) < epsilon) break;
                t = t - (currentX - x) / dx;
                t = Math.max(0, Math.min(1, t));
            }
            let u = 1 - t;
            let tt = t * t;
            let uu = u * u;
            let uuu = uu * u;
            let ttt = tt * t;
            return uuu * p0y + 3 * uu * t * p1y + 3 * u * tt * p2y + ttt * p3y;
        }

        function Calculate_Radius() {
            if (Elapsed < DURATION_INNER) {
                const progress = Elapsed / DURATION_INNER;
                const distanceFactor = Calculate_Bezier(progress, 0, 1, 0.4, 1, 0.6, 0, 1, 0);
                Radius = POSITION_START.length() * distanceFactor + DISTANCE_INNER * (1 - distanceFactor);
            } else if (Elapsed < DURATION_ALL) {
                const progress = (Elapsed - DURATION_INNER) / DURATION_END;
                const distanceFactor = Calculate_Bezier(progress, 0, 0, 0.9, 0.1, 0.7, 0.7, 1, 1);
                const startDistance = DISTANCE_INNER;
                const endDistance = POSITION_END.length();
                Radius = startDistance * (1 - distanceFactor) + endDistance * distanceFactor;
            }
        }

        function Calculate_Theta() {
            if (Elapsed < DURATION_INNER) {
                const progress = Elapsed / DURATION_INNER;
                Theta = Math.PI * 0.5 - Math.PI * (90 / 180) * Calculate_Bezier(progress, 0, 0, 0.4, 0, 0.4, 0, 1, 1);
            } else if (Elapsed > DURATION_INNER + DURATION_END && Elapsed < DURATION_ALL) {
                const progress = (Elapsed - DURATION_INNER - DURATION_END) / DURATION_ADJUST;
                Theta = Math.PI * (10 / 180) * Calculate_Bezier(progress, 0, 0, 0.4, 0, 0.3, 1, 1, 1);
            }
        }

        function Calculate_Phi() {
            if (Elapsed < DURATION_INNER) {
                const progress = Elapsed / DURATION_INNER;
                Phi = Math.PI * 4 * Calculate_Bezier(progress, 0, 0, 0.4, 0, 0.4, 0, 1, 1);
            } else if (Elapsed < DURATION_INNER + DURATION_END) {
                const progress = (Elapsed - DURATION_INNER) / DURATION_END;
                Phi = Math.PI * 2 * Calculate_Bezier(progress, 0, 0, 0, 0.2, 0.8, 0.1, 1, 1);
            } else if (Elapsed < DURATION_ALL) {
                const progress = (Elapsed - DURATION_INNER - DURATION_END) / DURATION_ADJUST;
                Phi = Math.PI * (120 / 180) * Calculate_Bezier(progress, 0, 0, 0, 0.4, 0.4, 0.9, 1, 1);
            }
        }

        let lastTime = performance.now();
        let countDistance = Math.PI;
        let countTheata = Math.PI;
        let time = 0.0;

        function animate() {
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            time += deltaTime;

            liquidShaderMaterial.uniforms.time.value = time;
            liquidShaderMaterial.uniforms.viewPos.value.copy(camera.position);
            liquidShaderMaterial.uniforms.cameraDistance.value = camera.position.length();

            if (Flag_CameraAnimation) {
                if (Time_CameraAnimation_Start === null) {
                    Time_CameraAnimation_Start = currentTime;
                    Position_Trun_Start = camera.position.clone();
                }
                Elapsed = currentTime - Time_CameraAnimation_Start;
                if (Elapsed < DURATION_ALL) {
                    Calculate_Radius();
                    Calculate_Theta();
                    Calculate_Phi();
                    const x = Radius * Math.cos(Theta) * Math.cos(Phi);
                    const y = Radius * Math.sin(Theta);
                    const z = Radius * Math.cos(Theta) * Math.sin(Phi);
                    camera.position.set(x, y, z);
                    camera.lookAt(0, 0, 0);
                }
                if (Elapsed > DURATION_ALL) {
                    Flag_CameraAnimation = false;
                    controls.maxDistance = 1200;
                    controls.enabled = true;
                }
            } else {
                countDistance += Math.PI * 0.01 * deltaTime;
                const currentDistance = camera.position.length();
                let newDistance = currentDistance + Math.sin(countDistance) * 2 * deltaTime;
                if (newDistance < 18) {
                    newDistance = 18;
                    countDistance += Math.PI * deltaTime;
                }
                const currentPhi = Math.atan2(camera.position.z, camera.position.x);
                const newPhi = currentPhi + Math.PI * 0.05 * deltaTime;
                countTheata += Math.PI * 0.2 * deltaTime;
                let currentTheta = Math.asin(camera.position.y / newDistance);
                if (currentTheta <= -Math.PI * 0.49) {
                    currentTheta = -Math.PI * 0.49;
                }
                if (currentTheta >= Math.PI * 0.49) {
                    currentTheta = Math.PI * 0.49;
                }
                const newTheta = currentTheta + Math.sin(countTheata) * Math.PI * 2.5 / 180 * deltaTime;
                const x = newDistance * Math.cos(newTheta) * Math.cos(newPhi);
                const y = newDistance * Math.sin(newTheta);
                const z = newDistance * Math.cos(newTheta) * Math.sin(newPhi);
                camera.position.set(x, y, z);
                camera.lookAt(0, 0, 0);
            }

            animatePoints();
            updateLines();
            updateCursorParticles();
            controls.update();
            composer.render();
            updateGlitch();

            requestAnimationFrame(animate);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersection = raycaster.ray.at(20);
            if (Math.random() < 0.5) {
                createCursorParticle(intersection.x, intersection.y, intersection.z);
            }
        }

        window.addEventListener('mousemove', onMouseMove);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

        const colorDistribution = [
            {
                type: "blue-white", prob: 0.45, colors: [
                    { r: 0.53, g: 0.67, b: 1.0 },
                    { r: 0.67, g: 0.73, b: 1.0 },
                    { r: 0.93, g: 0.93, b: 1.0 }
                ]
            },
            {
                type: "yellow", prob: 0.325, colors: [
                    { r: 1.0, g: 1.0, b: 0.8 },
                    { r: 1.0, g: 1.0, b: 0.6 }
                ]
            },
            {
                type: "orange-red", prob: 0.225, colors: [
                    { r: 1.0, g: 0.67, b: 0.4 },
                    { r: 1.0, g: 0.4, b: 0.4 }
                ]
            }
        ];

        const randomColor = () => {
            const rand = Math.random();
            let cumulativeProb = 0;
            for (const category of colorDistribution) {
                cumulativeProb += category.prob;
                if (rand <= cumulativeProb) {
                    const colorChoice = category.colors[Math.floor(Math.random() * category.colors.length)];
                    return new THREE.Color(colorChoice.r, colorChoice.g, colorChoice.b);
                }
            }
            return new THREE.Color(1, 1, 1);
        };

        function createUniverseDetail() {
            const starCount = 10000;
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const r = 2000 + Math.random() * 2000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                starPositions[i * 3] = r * Math.sin(theta) * Math.cos(phi);
                starPositions[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                starPositions[i * 3 + 2] = r * Math.cos(theta);
                const color = randomColor();
                starColors[i * 3] = color.r;
                starColors[i * 3 + 1] = color.g;
                starColors[i * 3 + 2] = color.b;
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            const starMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: 1 + Math.random() * 4,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                fog: true
            });
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);

            const galaxyStars = 3000;
            const galaxyPositions = new Float32Array(galaxyStars * 3);
            const galaxyColors = new Float32Array(galaxyStars * 3);
            const spiralArms = 4;
            const spiralSpread = 10;
            const minGalaxyRadius = 20;
            const maxGalaxyRadius = 200;

            const armWeights = [1, 1.5, 1, 1.5];
            const totalWeight = armWeights.reduce((sum, weight) => sum + weight, 0);
            const armAngles = [];
            let cumulativeWeight = 0;
            for (let i = 0; i < spiralArms; i++) {
                armAngles.push((cumulativeWeight / totalWeight) * (2 * Math.PI));
                cumulativeWeight += armWeights[i];
            }

            for (let i = 0; i < galaxyStars; i++) {
                let r = minGalaxyRadius + (maxGalaxyRadius - minGalaxyRadius) * Math.sqrt(Math.random());
                let armIndex = i % spiralArms;
                let baseArmAngle = armAngles[armIndex];
                let twist = r * 0.04;
                let randomScatter = (Math.random() - 0.5) * 0.4;
                let angle = baseArmAngle + twist + randomScatter;

                const x = r * Math.cos(angle) + (Math.random() - 0.5) * spiralSpread;
                const y = (Math.random() - 0.5) * (spiralSpread * 0.3);
                const z = r * Math.sin(angle) + (Math.random() - 0.5) * spiralSpread;
                galaxyPositions[i * 3] = x;
                galaxyPositions[i * 3 + 1] = y;
                galaxyPositions[i * 3 + 2] = z;

                let t = r / maxGalaxyRadius;
                let color = new THREE.Color();
                if (t < 0.5) {
                    color.set(0xfff4e5);
                } else {
                    color.set(0xffeedd);
                }
                galaxyColors[i * 3] = color.r;
                galaxyColors[i * 3 + 1] = color.g;
                galaxyColors[i * 3 + 2] = color.b;
            }

            const galaxyGeometry = new THREE.BufferGeometry();
            galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(galaxyPositions, 3));
            galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(galaxyColors, 3));
            const galaxyMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: isMobile ? 0.2 : 0.1,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                fog: true
            });
            const galaxyField = new THREE.Points(galaxyGeometry, galaxyMaterial);
            scene.add(galaxyField);

            const nebulaCount = 2000;
            const nebulaPositions = new Float32Array(nebulaCount * 3);
            const nebulaColors = new Float32Array(nebulaCount * 3);
            const nebulaMinRadius = 100;
            const nebulaMaxRadius = 300;
            for (let i = 0; i < nebulaCount; i++) {
                const u = Math.random();
                const r = Math.cbrt(u * (Math.pow(nebulaMaxRadius, 3) - Math.pow(nebulaMinRadius, 3)) + Math.pow(nebulaMinRadius, 3));

                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                const x = r * Math.sin(theta) * Math.cos(phi);
                const y = r * 0.3 * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(theta);
                nebulaPositions[i * 3] = x;
                nebulaPositions[i * 3 + 1] = y;
                nebulaPositions[i * 3 + 2] = z;

                const color = new THREE.Color(0x334455).lerp(new THREE.Color(0x88aaff), Math.random() * 0.3);
                nebulaColors[i * 3] = color.r;
                nebulaColors[i * 3 + 1] = color.g;
                nebulaColors[i * 3 + 2] = color.b;
            }
            const nebulaGeometry = new THREE.BufferGeometry();
            nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
            nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
            const nebulaMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: isMobile ? 0.2 : 0.1,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                fog: true
            });
            const nebulaField = new THREE.Points(nebulaGeometry, nebulaMaterial);
            scene.add(nebulaField);

            function createSparkleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.7)');
                gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                context.fillStyle = gradient;
                context.fillRect(0, 0, 128, 128);
                return new THREE.CanvasTexture(canvas);
            }

            const sparkleTexture = createSparkleTexture();
            const sparkleCount = 500;
            for (let i = 0; i < sparkleCount; i++) {
                const r = 3000 + Math.random() * 1000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                const sprite = new THREE.Sprite(
                    new THREE.SpriteMaterial({
                        map: sparkleTexture,
                        color: randomColor(),
                        transparent: true,
                        opacity: 1,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        fog: false
                    })
                );
                sprite.position.set(
                    r * Math.sin(theta) * Math.cos(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(theta)
                );
                sprite.scale.set(30 + Math.random() * 50, 30 + Math.random() * 50, 1);
                scene.add(sprite);
            }

            const clusterCount = 10;
            for (let c = 0; c < clusterCount; c++) {
                const clusterRadius = 3000 + Math.random() * 2000;
                const clusterTheta = Math.acos(2 * Math.random() - 1);
                const clusterPhi = Math.random() * 2 * Math.PI;
                const clusterCenter = new THREE.Vector3(
                    clusterRadius * Math.sin(clusterTheta) * Math.cos(clusterPhi),
                    clusterRadius * Math.sin(clusterTheta) * Math.sin(clusterPhi),
                    clusterRadius * Math.cos(clusterTheta)
                );
                const galaxyInCluster = 3 + Math.floor(Math.random() * 5);
                for (let g = 0; g < galaxyInCluster; g++) {
                    const particleCount = 500 + Math.floor(Math.random() * 1000);
                    const clusterPositions = new Float32Array(particleCount * 3);
                    const clusterColors = new Float32Array(particleCount * 3);
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100,
                        (Math.random() - 0.5) * 100
                    );
                    for (let i = 0; i < particleCount; i++) {
                        const r = Math.random() * 50;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const phi = Math.random() * 2 * Math.PI;
                        clusterPositions[i * 3] = clusterCenter.x + offset.x + r * Math.sin(theta) * Math.cos(phi);
                        clusterPositions[i * 3 + 1] = clusterCenter.y + offset.y + r * Math.sin(theta) * Math.sin(phi);
                        clusterPositions[i * 3 + 2] = clusterCenter.z + offset.z + r * Math.cos(theta);
                        const color = new THREE.Color(0xffffff).lerp(new THREE.Color(0xaabbff), Math.random() * 0.3);
                        clusterColors[i * 3] = color.r;
                        clusterColors[i * 3 + 1] = color.g;
                        clusterColors[i * 3 + 2] = color.b;
                    }
                    const clusterGeometry = new THREE.BufferGeometry();
                    clusterGeometry.setAttribute('position', new THREE.BufferAttribute(clusterPositions, 3));
                    clusterGeometry.setAttribute('color', new THREE.BufferAttribute(clusterColors, 3));
                    const clusterMaterial = new THREE.PointsMaterial({
                        vertexColors: true,
                        size: isMobile ? 0.2 + Math.random() * 0.3 : 0.1 + Math.random() * 0.2,
                        sizeAttenuation: true,
                        transparent: true,
                        opacity: 0.4,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                        fog: true
                    });
                    const clusterField = new THREE.Points(clusterGeometry, clusterMaterial);
                    scene.add(clusterField);
                }
            }

            const distantGalaxyCount = 1000;
            for (let g = 0; g < distantGalaxyCount; g++) {
                const particleCount = 200 + Math.floor(Math.random() * 600);
                const galaxyRadius = 1500 + Math.random() * 2000;
                const galaxyTheta = Math.acos(2 * Math.random() - 1);
                const galaxyPhi = Math.random() * 2 * Math.PI;
                const distantPositions = new Float32Array(particleCount * 3);
                const distantColors = new Float32Array(particleCount * 3);
                for (let i = 0; i < particleCount; i++) {
                    const r = Math.random() * 30;
                    const theta = Math.acos(2 * Math.random() - 1);
                    const phi = Math.random() * 2 * Math.PI;
                    distantPositions[i * 3] = galaxyRadius * Math.sin(galaxyTheta) * Math.cos(galaxyPhi) + r * Math.sin(theta) * Math.cos(phi);
                    distantPositions[i * 3 + 1] = galaxyRadius * Math.sin(galaxyTheta) * Math.sin(galaxyPhi) + r * Math.sin(theta) * Math.sin(phi);
                    distantPositions[i * 3 + 2] = galaxyRadius * Math.cos(galaxyTheta) + r * Math.cos(theta);
                    const color = randomColor();
                    distantColors[i * 3] = color.r;
                    distantColors[i * 3 + 1] = color.g;
                    distantColors[i * 3 + 2] = color.b;
                }
                const distantGeometry = new THREE.BufferGeometry();
                distantGeometry.setAttribute('position', new THREE.BufferAttribute(distantPositions, 3));
                distantGeometry.setAttribute('color', new THREE.BufferAttribute(distantColors, 3));
                const distantMaterial = new THREE.PointsMaterial({
                    vertexColors: true,
                    size: 0.1 + Math.random() * 5,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.05,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    fog: true
                });
                const distantField = new THREE.Points(distantGeometry, distantMaterial);
                scene.add(distantField);
            }

            // Adding 10 black holes
            const blackHoleCount = 10;
            const blackHoleMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                fog: false
            });
            for (let i = 0; i < blackHoleCount; i++) {
                const radius = 25 + Math.random() * 25;
                const blackHoleGeometry = new THREE.SphereGeometry(radius, 16, 16);
                const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
                const r = 1000 + Math.random() * 1000;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;
                blackHole.position.set(
                    r * Math.sin(theta) * Math.cos(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(theta)
                );
                blackHole.castShadow = false;
                blackHole.receiveShadow = false;
                scene.add(blackHole);
            }
        }

        createUniverseDetail();
    </script>
</body>
</html>